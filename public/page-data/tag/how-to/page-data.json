{"componentChunkName":"component---src-templates-tag-js","path":"/tag/how-to/","result":{"data":{"ghostTag":{"slug":"how-to","name":"How To","feature_image":null,"description":null,"meta_title":null,"meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__60210daa2dc76c001e5a3301","title":"Headless Ghost and Fission","slug":"headless-ghost-blog-fission","featured":false,"feature_image":"https://images.unsplash.com/photo-1545062990-4a95e8e4b96d?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxMTc3M3wwfDF8c2VhcmNofDF8fGdob3N0fGVufDB8fHw&ixlib=rb-1.2.1&q=80&w=1080","excerpt":"Learn about the Headless experiments at Fission, and walk through the tutorial to build a Next.js blog powered by Headless Ghost and Fission.","custom_excerpt":"Learn about the Headless experiments at Fission, and walk through the tutorial to build a Next.js blog powered by Headless Ghost and Fission.","created_at_pretty":"08 February, 2021","published_at_pretty":"08 February, 2021","updated_at_pretty":"08 February, 2021","created_at":"2021-02-08T02:08:41.000-08:00","published_at":"2021-02-08T08:59:29.000-08:00","updated_at":"2021-02-08T08:59:29.000-08:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Helder S Ribeiro","slug":"agentofuser","bio":"Deleting the chasm between using and programming computers.","profile_image":"https://s3.fission.codes/2021/02/2020-1024px.jpg","twitter":"@agentofuser","facebook":null,"website":"https://agentofuser.com"}],"primary_author":{"name":"Helder S Ribeiro","slug":"agentofuser","bio":"Deleting the chasm between using and programming computers.","profile_image":"https://s3.fission.codes/2021/02/2020-1024px.jpg","twitter":"@agentofuser","facebook":null,"website":"https://agentofuser.com"},"primary_tag":{"name":"How To","slug":"how-to","description":null,"feature_image":null,"meta_description":null,"meta_title":null},"tags":[{"name":"How To","slug":"how-to","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"Ghost","slug":"ghost-tag","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"Headless Ghost","slug":"headless-ghost","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"ReactJS","slug":"reactjs","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"Next.js","slug":"next-js","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"starter","slug":"starter","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"Headless CMS","slug":"headless-cms","description":null,"feature_image":null,"meta_description":null,"meta_title":null}],"plaintext":"We're exploring a number of \"Headless\" combinations at Fission. The first one is\nwith the Ghost Content Management System (CMS). We use Ghost to run this blog\nand want to start using it to integrate with and power our home page, so it's a\ngreat place for us to start.\n\nThe basic pattern of \"Headless\" is that your authors and editors login to a\nserver based system with all the authoring and editing tools they are used to,\nbut then the \"head\" ‚Äì the usual template system and user facing website ‚Äì isn't\nused. Instead, a modern front end framework is custom designed and built to take\nthe published content of the CMS and host it. This fits great with the Fission\napp publishing platform.\n\nAfter we've got the basics of a headless publishing workflow setup with Fission,\nwe'll move on to using our Webnative framework to add personalization at the\nedge, but that will come in later posts.\n\nAside from Ghost, we're also looking at Headless WordPress\n[https://talk.fission.codes/t/headless-wordpress/1448]  and Headless Drupal\n[https://talk.fission.codes/t/headless-drupal/1513]. Let us know in the forum if\nyou've got other Headless projects that you'd like to combine with Fission!\n\nBuild a Next.js Blog powered by Headless Ghost and Fission\nFollow the tutorial below to get started with your own Headless Ghost, or visit\nit on Github for the README version\n[https://github.com/fission-suite/nextjs-blog-starter-typescript-ghost].\n\nYou want to have a modern static website/app built with React, deployed to a CDN\n(even a distributed [https://ipfs.io/]  one), and loading super fast for\nvisitors and search engines.\n\nYou want to avoid the headaches and costs of managing and securing servers for\ntraditional content management systems (CMSs) like Ghost and WordPress.\n\nThat's what static site generators (like Next.js, Gatsby, and others\n[https://staticgen.com/]) are for, right?\n\nBut,  you don't  want to have to retrain  every writer and content creator on\nyour team to use Markdown  and Git. Ghost and WordPress are familiar, pretty,\nand usable. They have been iterated over years to be approachable by almost\nanyone.\n\nWhat do you do? That's right you cut the CMS' head off üî™\n\nMore politely, you decouple  the interface used for authoring  content from the\nsystems used for rendering  and distributing  it.\n\nWith CMS and website decoupled, you can protect the CMS inside an intranet\nwithout exposing it to outside danger, or even use it as a desktop word\nprocessor running only on your machine, as I'll show you in this tutorial.\n\nTo make things easier we've made a template Next.js website that connects to\nGhost and pulls content from it. Follow along and try it out. Feedback welcome\n:)\n\n\n--------------------------------------------------------------------------------\n\n * ‚ú®¬†¬†Getting Started * üëª¬†¬†Setting Up Ghost * Public or Local Ghost?\n       * Setting Up Local Ghost\n       * Exposing the Ghost Content API\n      \n      \n    * üíª¬†¬†Running Next.js Locally\n    * üåê¬†¬†Deploying to Fission * üî∞¬†¬†Fission CLI Install and Sign Up\n       * üå±¬†¬†Register New Fission App\n       * üöÄ ¬†¬†Aand... Launch!\n       * ü§ñ¬†¬†(Semi-)Automatic Deployment with the\n         GitHub\n         Action\n      \n      \n   \n   \n * üôè¬†¬†Show your support\n\n\n--------------------------------------------------------------------------------\n\nThis starter template is based on the official blog-starter-typescript\n[https://github.com/vercel/next.js/tree/canary/examples/blog-starter-typescript] \n from Next.js [https://nextjs.org].\n\nWe changed it only enough to make it possible to fetch and publish blog posts\nfrom the Ghost CMS, while keeping the ability to write Markdown files in the git\nrepo. It's a purely additive change.\n\nThere's also a GitHub Action to build and publish the static website to Fission.\nIt works automatically on pushes to the git repo, and can be triggered manually\nafter updating the content on Ghost. (The default Ghost webhook isn't\ncustomizable to trigger a GitHub Action, but that can be added as a plugin.)\n\nThe Markdown blog posts are stored in /_posts  as files with frontmatter\nsupport. Adding a new Markdown file in there will create a new blog post.\n\nThe Ghost blog posts are fetched using Ghost's Content API library.\n\n‚ú®¬†¬†Getting Started\nLet's start by making this starter yours:\n\n * Click Use this template  at the starter page on GitHub\n   [https://github.com/fission-suite/nextjs-blog-starter-typescript-ghost]\n   \n   That will make a copy of the starter into a new repo under your account with\n   a fresh git history. You can pick a different name for it too; in that case\n   replace nextjs-blog-starter-typescript-ghost  with your chosen name below.\n   \n   \n * Clone the repo (replace with your own URL):\n   \n   git clone git@github.com:fission-suite/nextjs-blog-starter-typescript-ghost.git\n   \n   \n   \n * cd into the repo:\n   \n   cd nextjs-blog-starter-typescript-ghost\n   \n   \n   \n * Install dependencies\n   \n   yarn\n   \n   \n   \n\nAll command-line instructions and directory paths from now on assume the current\ndirectory is the root of the cloned repo.\n\nüëª¬†¬†Setting Up Ghost\nPublic or Local Ghost?\nRunning a local Ghost instance is good for testing. But also, if you have no\nneed for a Ghost instance running all the time out on the internet (for example,\nif you are the only author) you can do this for your production website, using\nGhost locally for its nice interface if you prefer that to editing Markdown\nfiles. No servers to secure, no bills to pay.\n\nSetting Up Local Ghost\nIf you have a Ghost instance running already somewhere, move on to the next\nstep. If you don't, you can set one up on your own machine with Docker.\n\nTo create a local Ghost instance with Docker, run the following at the root of\nyour repo:\n\nyarn ghost-local-create\n\n\nGhost data will be stored at ./ghost, which is in .gitignore  by default. In a \nprivate  repo you can choose to commit that too and have your Ghost content\nversioned and available whenever you need it.\n\nThere are other scripts like ghost-local-start, ghost-local-stop, and \nghost-local-remove  which you might find handy to manage the Docker container.\n\nAfter Docker downloads and sets up Ghost, it will be accessible on your browser\nat http://localhost:3001.\n\nNext you need to create an admin account on your newly-created Ghost. To do\nthat, visit the admin interface at http://localhost:3001/ghost  and follow the\nwizard.\n\nExposing the Ghost Content API\nI'll use http://localhost:3001  for the examples, but you can replace that with\nyour Ghost URL if you have an instance already running somewhere else.\n\n * Go to the admin interface at http://localhost:3001/ghost\n * On the left-hand sidebar, click on \"Integrations\"\n * On the Integrations screen, click on +Add custom integration\n   [http://localhost:3001/ghost/#/settings/integrations/new/]\n * Give it a name, like nextjs, and click \"Create\" then \"Save\"\n\nNow the important part:\n\n * On the same screen, you'll find two fields we need: Content API Key  and API\n   URL\n * Copy those into a new .env.local  file, like this:\n\n# .env.local\n# replace values with your own\nGHOST_API_URL=http://localhost:3001\nGHOST_API_KEY=2a9356e4a5214c883ba886e58e\n\n\n‚ö†Ô∏è This file is ignored by git by default. Don't  commit env.local  to git\nunless you know what you're doing.\n\nAlright! Ghost part's done.\n\nüíª¬†¬†Running Next.js Locally\nNext.js is the missing static website head  to our headless Ghost. Let's stitch\nthem together! This should be enough:\n\nyarn dev\n\n\nYour blog should be up and running at http://localhost:3000! (If anything\nunexpected happens, please post an issue\n[https://github.com/fission-suite/nextjs-blog-starter-typescript-ghost/issues/new]\n.)\n\nNow you can change the Next.js website code and the content on Ghost, and\niterate quickly on them in the browser.\n\nNote: live-reload works for Next.js code and Markdown files; to see changes to\nGhost content you need to refresh the page.\n\nüåê¬†¬†Deploying to Fission\nWhen you're ready to publish, the first step is exporting your website to a set\nof static files:\n\nyarn build\n\n\nThat should create a directory at ./out  with all your ready-to-publish files.\n\nNext we use the Fission CLI to send that out onto the internets.\n\nüî∞¬†¬†Fission CLI Install and Sign Up\nTo install the Fission command-line interface using brew, run:\n\nbrew tap fission-suite/fission\nbrew install fission-cli\n\n\nFor more ways of installing the Fission CLI, please check the documentation\n[https://guide.fission.codes/developers/installation].\n\nIf you don't have a Fission account, you can create one without leaving the\ncommand-line by running:\n\nfission setup\n\n\nüå±¬†¬†Register New Fission App\nYou can pick a subdomain or let Fission choose a random one for you.\n\nTo host the Next.js website at a random subdomain on .fission.app, run:\n\nfission app register\n\n\nTo choose your own subdomain, use the --name  option like this:\n\nfission app register --name my-beautiful-subdomain\n\n\nThat will create a fission.yaml  file. This one is safe to commit to git, and\nyou should  do that if you want to use the GitHub Action to build and deploy the\nwebsite for you. Make sure there is a line saying build: ./out  in it. That's\nthe directory where Next.js puts the exported website files.\n\nüöÄ ¬†¬†Aand... Launch!\nOne last step:\n\nfission app publish\n\n\nAnd you're done! Your website should be up at a random URL returned to you by\nthe Fission CLI or at my-beautiful-subdomain.fission.app  if you used the --name \n option. Yay!\n\nü§ñ¬†¬†(Semi-)Automatic Deployment with the GitHub Action\nIf you don't want to run the build locally and deploy to Fission every time you\nmake a change to the Next.js code or Markdown files (who does?), this starter\ncomes with a GitHub Action that automates that for you.\n\nTo get it working you need to set up 3 secrets for your repo. To do that, go to\nthe \"Settings\" > \"Secrets\"  screen on your GitHub repo, then create a \"New\nrepository secret\"  for each of these:\n\n * GHOST_API_URL\n * GHOST_API_KEY\n * FISSION_KEY\n\nThe values for the GHOST_API_  fields are the same ones you used for the \n.env.local  file above.\n\nThe FISSION_KEY  was created and stored locally for you by the Fission CLI when\nyou set it up. Here's how you get it:\n\ncat ~/.config/fission/key/machine_id.ed25519 | base64\n\n\nWith all 3 secrets set up, you can trigger the deploy  action manually by\nclicking on \"Run workflow\" > \"Run workflow\", or see it in action after your next\n git push.\n\n\n--------------------------------------------------------------------------------\n\nNote:\n\n‚ö†Ô∏è¬†¬†To fetch the content from Ghost, the GitHub Action must be able to access\nthe URL  entered in the GHOST_API_URL  secret.\n\nIf you are running a local Ghost instance on your machine, http://localhost:3001 \n won't be visible to the outside.\n\nA simple way of exposing your local Ghost instance to a publicly-accessible URL\nis by using one of the open source alternatives to ngrok\n[https://github.com/anderspitman/awesome-tunneling]  or ngrok\n[https://ngrok.com/]  itself.\n\nWith ngrok you do something like this:\n\nngrok http 3001\n\n\n‚ö†Ô∏è¬†¬†This is great for testing, but not secure. Look into using https  if you're\ngoing to rely on this and don't want your Ghost API key and data to leak.\n\n\n--------------------------------------------------------------------------------\n\n> Why \"(semi-)\" automatic then? ü§î\n\n\nGlad you asked. The GitHub Action can detect when you push to the GitHub repo\nbecause there's a built-in \"on push\" event  that can be used to trigger  it.\n\nBut when you create a new post on Ghost or update an existing one, GitHub needs\na way of finding out about it so it can run the deploy action. There's no git\npush  event happening, so the trigger is usually a webhook\n[https://docs.github.com/en/rest/reference/actions#create-a-workflow-dispatch-event] \n (i.e. a POST request you send to a GitHub API URL.)\n\nüôÇ¬†¬†Luckily, Ghost comes with the built-in ability to send webhooks when content\nchanges happen.\n\nüôÉUnluckily, though, Ghost doesn't let you customize the payload that goes in\nthe webhook requests it sends, and GitHub requires  a certain field to be\npresent telling it which ref  (usually a branch) you are referring to.\n\nBottom line: after changing things on Ghost, you need to trigger a build\nmanually.\n\nYou can do that via the GitHub interface (\"Actions\" > \"Continuous Deployment\" >\n\"Run workflow\" > \"Run workflow\"), or by running the handy script  we added to\nthis starter:\n\nGITHUB_USER=your-username GITHUB_REPO=your-repo GITHUB_AUTH_TOKEN=your-auth-token trigger-github-deploy-action.sh\n\n\nHere's how you can get an auth token\n[https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token]\n.\n\nThis situation is definitely not ideal, and can be solved with Ghost plugins,\nbut we wanted to stick to the basic install.\n\nüôè¬†¬†Show your support\nPlease give a¬†¬†‚≠êÔ∏è\n[https://github.com/fission-suite/nextjs-blog-starter-typescript-ghost]¬†¬†if you\nliked this project! We appreciate it :)","html":"<p>We're exploring a number of \"Headless\" combinations at Fission. The first one is with the Ghost Content Management System (CMS). We use Ghost to run this blog and want to start using it to integrate with and power our home page, so it's a great place for us to start.</p><p>The basic pattern of \"Headless\" is that your authors and editors login to a server based system with all the authoring and editing tools they are used to, but then the \"head\" ‚Äì the usual template system and user facing website ‚Äì isn't used. Instead, a modern front end framework is custom designed and built to take the published content of the CMS and host it. This fits great with the Fission app publishing platform.</p><p>After we've got the basics of a headless publishing workflow setup with Fission, we'll move on to using our Webnative framework to add personalization at the edge, but that will come in later posts.</p><p>Aside from Ghost, we're also looking at <a href=\"https://talk.fission.codes/t/headless-wordpress/1448\">Headless WordPress</a> and <a href=\"https://talk.fission.codes/t/headless-drupal/1513\">Headless Drupal</a>. Let us know in the forum if you've got other Headless projects that you'd like to combine with Fission!</p><h2 id=\"build-a-next-js-blog-powered-by-headless-ghost-and-fission\">Build a Next.js Blog powered by Headless Ghost and Fission</h2><p>Follow the tutorial below to get started with your own Headless Ghost, or <a href=\"https://github.com/fission-suite/nextjs-blog-starter-typescript-ghost\">visit it on Github for the README version</a>.</p><!--kg-card-begin: markdown--><p>You want to have a modern static website/app built with React, deployed to a CDN (even a <a href=\"https://ipfs.io/\">distributed</a> one), and loading super fast for visitors and search engines.</p>\n<p>You want to avoid the headaches and costs of managing and securing servers for traditional content management systems (CMSs) like Ghost and WordPress.</p>\n<p>That's what static site generators (like Next.js, Gatsby, and <a href=\"https://staticgen.com/\">others</a>) are for, right?</p>\n<p><em>But,</em> you <em>don't</em> want to have to <strong>retrain</strong> every writer and content creator on your team to use <em>Markdown</em> and <em>Git</em>. Ghost and WordPress are familiar, pretty, and usable. They have been iterated over years to be approachable by almost anyone.</p>\n<p>What do you do? That's right you cut the CMS' head off üî™</p>\n<p>More politely, you <em>decouple</em> the interface used for <em>authoring</em> content from the systems used for <em>rendering</em> and <em>distributing</em> it.</p>\n<p>With CMS and website decoupled, you can protect the CMS inside an intranet without exposing it to outside danger, or even use it as a desktop word processor running only on your machine, as I'll show you in this tutorial.</p>\n<p>To make things easier we've made a template Next.js website that connects to Ghost and pulls content from it. Follow along and try it out. Feedback welcome :)</p>\n<hr>\n<ul>\n<li><a href=\"#gettingstarted\">‚ú®¬†¬†Getting Started</a>\n<ul>\n<li><a href=\"#settingupghost\">üëª¬†¬†Setting Up Ghost</a>\n<ul>\n<li><a href=\"#publicorlocalghost\">Public or Local Ghost?</a></li>\n<li><a href=\"#settinguplocalghost\">Setting Up Local Ghost</a></li>\n<li><a href=\"#exposingtheghostcontentapi\">Exposing the Ghost Content API</a></li>\n</ul>\n</li>\n<li><a href=\"#runningnextjslocally\">üíª¬†¬†Running Next.js Locally</a></li>\n<li><a href=\"#deployingtofission\">üåê¬†¬†Deploying to Fission</a>\n<ul>\n<li><a href=\"#fissioncliinstallandsignup\">üî∞¬†¬†Fission CLI Install and Sign Up</a></li>\n<li><a href=\"#registernewfissionapp\">üå±¬†¬†Register New Fission App</a></li>\n<li><a href=\"#aandlaunch\">üöÄ ¬†¬†Aand... Launch!</a></li>\n<li><a href=\"#semiautomaticdeploymentwiththegithubaction\">ü§ñ¬†¬†(Semi-)Automatic Deployment with the GitHub Action</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#showyoursupport\">üôè¬†¬†Show your support</a></li>\n</ul>\n<hr>\n<p>This starter template is based on the official <a href=\"https://github.com/vercel/next.js/tree/canary/examples/blog-starter-typescript\">blog-starter-typescript</a> from <a href=\"https://nextjs.org\">Next.js</a>.</p>\n<p>We changed it only enough to make it possible to fetch and publish blog posts from the Ghost CMS, while keeping the ability to write Markdown files in the git repo. It's a purely additive change.</p>\n<p>There's also a GitHub Action to build and publish the static website to Fission. It works automatically on pushes to the git repo, and can be triggered manually after updating the content on Ghost. (The default Ghost webhook isn't customizable to trigger a GitHub Action, but that can be added as a plugin.)</p>\n<p>The Markdown blog posts are stored in <code>/_posts</code> as files with frontmatter support. Adding a new Markdown file in there will create a new blog post.</p>\n<p>The Ghost blog posts are fetched using Ghost's Content API library.</p>\n<h2 id=\"gettingstarted\">‚ú®¬†¬†Getting Started</h2>\n<p>Let's start by making this starter yours:</p>\n<ul>\n<li>\n<p>Click <strong>Use this template</strong> at the <a href=\"https://github.com/fission-suite/nextjs-blog-starter-typescript-ghost\">starter page on GitHub</a></p>\n<p>That will make a copy of the starter into a new repo under your account with a fresh git history. You can pick a different name for it too; in that case replace <code>nextjs-blog-starter-typescript-ghost</code> with your chosen name below.</p>\n</li>\n<li>\n<p>Clone the repo (replace with your own URL):</p>\n<pre><code>git clone git@github.com:fission-suite/nextjs-blog-starter-typescript-ghost.git\n</code></pre>\n</li>\n<li>\n<p>cd into the repo:</p>\n<pre><code>cd nextjs-blog-starter-typescript-ghost\n</code></pre>\n</li>\n<li>\n<p>Install dependencies</p>\n<pre><code>yarn\n</code></pre>\n</li>\n</ul>\n<p>All command-line instructions and directory paths from now on assume the current directory is the root of the cloned repo.</p>\n<h3 id=\"settingupghost\">üëª¬†¬†Setting Up Ghost</h3>\n<h4 id=\"publicorlocalghost\">Public or Local Ghost?</h4>\n<p>Running a local Ghost instance is good for testing. But also, if you have no need for a Ghost instance running all the time out on the internet (for example, if you are the only author) you can do this for your production website, using Ghost locally for its nice interface if you prefer that to editing Markdown files. No servers to secure, no bills to pay.</p>\n<h4 id=\"settinguplocalghost\">Setting Up Local Ghost</h4>\n<p>If you have a Ghost instance running already somewhere, move on to the next step. If you don't, you can set one up on your own machine with Docker.</p>\n<p>To create a local Ghost instance with Docker, run the following at the root of your repo:</p>\n<pre><code class=\"language-bash\">yarn ghost-local-create\n</code></pre>\n<p>Ghost data will be stored at <code>./ghost</code>, which is in <code>.gitignore</code> by default. In a <strong>private</strong> repo you can choose to commit that too and have your Ghost content versioned and available whenever you need it.</p>\n<p>There are other scripts like <code>ghost-local-start</code>, <code>ghost-local-stop</code>, and <code>ghost-local-remove</code> which you might find handy to manage the Docker container.</p>\n<p>After Docker downloads and sets up Ghost, it will be accessible on your browser at <a href=\"http://localhost:3001\">http://localhost:3001</a>.</p>\n<p>Next you need to create an admin account on your newly-created Ghost. To do that, visit the admin interface at <a href=\"http://localhost:3001/ghost\">http://localhost:3001/ghost</a> and follow the wizard.</p>\n<h4 id=\"exposingtheghostcontentapi\">Exposing the Ghost Content API</h4>\n<p>I'll use <code>http://localhost:3001</code> for the examples, but you can replace that with your Ghost URL if you have an instance already running somewhere else.</p>\n<ul>\n<li>Go to the admin interface at <a href=\"http://localhost:3001/ghost\">http://localhost:3001/ghost</a></li>\n<li>On the left-hand sidebar, click on &quot;Integrations&quot;</li>\n<li>On the Integrations screen, click on <a href=\"http://localhost:3001/ghost/#/settings/integrations/new/\">+Add custom integration</a></li>\n<li>Give it a name, like <code>nextjs</code>, and click &quot;Create&quot; then &quot;Save&quot;</li>\n</ul>\n<p>Now the important part:</p>\n<ul>\n<li>On the same screen, you'll find two fields we need: <strong>Content API Key</strong> and <strong>API URL</strong></li>\n<li>Copy those into a new <code>.env.local</code> file, like this:</li>\n</ul>\n<pre><code class=\"language-bash\"># .env.local\n# replace values with your own\nGHOST_API_URL=http://localhost:3001\nGHOST_API_KEY=2a9356e4a5214c883ba886e58e\n</code></pre>\n<p>‚ö†Ô∏è <em>This file is ignored by git by default. <strong>Don't</strong> commit <code>env.local</code> to git unless you know what you're doing.</em></p>\n<p>Alright! Ghost part's done.</p>\n<h3 id=\"runningnextjslocally\">üíª¬†¬†Running Next.js Locally</h3>\n<p>Next.js is the missing static website <em>head</em> to our <em>head</em>less Ghost. Let's stitch them together! This should be enough:</p>\n<pre><code class=\"language-bash\">yarn dev\n</code></pre>\n<p>Your blog should be up and running at <a href=\"http://localhost:3000\">http://localhost:3000</a>! <em>(If anything unexpected happens, please post an <a href=\"https://github.com/fission-suite/nextjs-blog-starter-typescript-ghost/issues/new\">issue</a>.)</em></p>\n<p>Now you can change the Next.js website code and the content on Ghost, and iterate quickly on them in the browser.</p>\n<p><em>Note: live-reload works for Next.js code and Markdown files; to see changes to Ghost content you need to refresh the page.</em></p>\n<h3 id=\"deployingtofission\">üåê¬†¬†Deploying to Fission</h3>\n<p>When you're ready to publish, the first step is exporting your website to a set of static files:</p>\n<pre><code class=\"language-bash\">yarn build\n</code></pre>\n<p>That should create a directory at <code>./out</code> with all your ready-to-publish files.</p>\n<p>Next we use the Fission CLI to send that out onto the internets.</p>\n<h4 id=\"fissioncliinstallandsignup\">üî∞¬†¬†Fission CLI Install and Sign Up</h4>\n<p>To install the Fission command-line interface using brew, run:</p>\n<pre><code class=\"language-bash\">brew tap fission-suite/fission\nbrew install fission-cli\n</code></pre>\n<p>For more ways of installing the Fission CLI, please check the <a href=\"https://guide.fission.codes/developers/installation\">documentation</a>.</p>\n<p>If you don't have a Fission account, you can create one without leaving the command-line by running:</p>\n<pre><code class=\"language-bash\">fission setup\n</code></pre>\n<h4 id=\"registernewfissionapp\">üå±¬†¬†Register New Fission App</h4>\n<p>You can pick a subdomain or let Fission choose a random one for you.</p>\n<p>To host the Next.js website at a random subdomain on <code>.fission.app</code>, run:</p>\n<pre><code class=\"language-bash\">fission app register\n</code></pre>\n<p>To choose your own subdomain, use the <code>--name</code> option like this:</p>\n<pre><code class=\"language-bash\">fission app register --name my-beautiful-subdomain\n</code></pre>\n<p>That will create a <code>fission.yaml</code> file. <strong>This one is safe to commit to git</strong>, and you <em>should</em> do that if you want to use the GitHub Action to build and deploy the website for you. Make sure there is a line saying <code>build: ./out</code> in it. That's the directory where Next.js puts the exported website files.</p>\n<h4 id=\"aandlaunch\">üöÄ ¬†¬†Aand... Launch!</h4>\n<p>One last step:</p>\n<pre><code class=\"language-bash\">fission app publish\n</code></pre>\n<p>And you're done! Your website should be up at a random URL returned to you by the Fission CLI or at <code>my-beautiful-subdomain.fission.app</code> if you used the <code>--name</code> option. Yay!</p>\n<h4 id=\"semiautomaticdeploymentwiththegithubaction\">ü§ñ¬†¬†(Semi-)Automatic Deployment with the GitHub Action</h4>\n<p>If you don't want to run the build locally and deploy to Fission every time you make a change to the Next.js code or Markdown files (who does?), this starter comes with <strong>a GitHub Action that automates that for you</strong>.</p>\n<p>To get it working you need to set up 3 secrets for your repo. To do that, go to the <strong>&quot;Settings&quot; &gt; &quot;Secrets&quot;</strong> screen on your GitHub repo, then create a <strong>&quot;New repository secret&quot;</strong> for each of these:</p>\n<ul>\n<li><code>GHOST_API_URL</code></li>\n<li><code>GHOST_API_KEY</code></li>\n<li><code>FISSION_KEY</code></li>\n</ul>\n<p>The values for the <code>GHOST_API_</code> fields are the same ones you used for the <code>.env.local</code> file above.</p>\n<p>The <code>FISSION_KEY</code> was created and stored locally for you by the Fission CLI when you set it up. Here's how you get it:</p>\n<pre><code>cat ~/.config/fission/key/machine_id.ed25519 | base64\n</code></pre>\n<p>With all 3 secrets set up, you can trigger the <code>deploy</code> action manually by clicking on <strong>&quot;Run workflow&quot; &gt; &quot;Run workflow&quot;</strong>, or see it in action after your next <code>git push</code>.</p>\n<hr>\n<p>Note:</p>\n<p>‚ö†Ô∏è¬†¬†To fetch the content from Ghost, <strong>the GitHub Action must be able to access the URL</strong> entered in the <code>GHOST_API_URL</code> secret.</p>\n<p>If you are running a local Ghost instance on your machine, <code>http://localhost:3001</code> won't be visible to the outside.</p>\n<p>A simple way of exposing your local Ghost instance to a publicly-accessible URL is by using one of the <a href=\"https://github.com/anderspitman/awesome-tunneling\">open source alternatives to ngrok</a> or <a href=\"https://ngrok.com/\">ngrok</a> itself.</p>\n<p>With ngrok you do something like this:</p>\n<pre><code>ngrok http 3001\n</code></pre>\n<p>‚ö†Ô∏è¬†¬†This is great for testing, but <strong>not secure</strong>. Look into using <code>https</code> if you're going to rely on this and don't want your Ghost API key and data to leak.</p>\n<hr>\n<blockquote>\n<p>Why <strong>&quot;(semi-)</strong>&quot; automatic then? ü§î</p>\n</blockquote>\n<p>Glad you asked. The GitHub Action can detect when you push to the GitHub repo because <strong>there's a built-in &quot;on push&quot; event</strong> that can be used to <strong>trigger</strong> it.</p>\n<p>But when you create a new post on Ghost or update an existing one, GitHub needs a way of finding out about it so it can run the deploy action. There's no <code>git push</code> event happening, so the trigger is usually a <a href=\"https://docs.github.com/en/rest/reference/actions#create-a-workflow-dispatch-event\"><strong>webhook</strong></a> (i.e. a POST request you send to a GitHub API URL.)</p>\n<p>üôÇ¬†¬†Luckily, Ghost comes with the built-in ability to send webhooks when content changes happen.</p>\n<p>üôÉ¬†¬†<strong><em>Un</em>luckily</strong>, though, Ghost doesn't let you customize the payload that goes in the webhook requests it sends, and GitHub <strong>requires</strong> a certain field to be present telling it which <code>ref</code> (usually a branch) you are referring to.</p>\n<p>Bottom line: <strong>after changing things <em>on Ghost</em>, you need to trigger a build manually</strong>.</p>\n<p>You can do that via the GitHub interface (&quot;Actions&quot; &gt; &quot;Continuous Deployment&quot; &gt; &quot;Run workflow&quot; &gt; &quot;Run workflow&quot;), or by <strong>running the handy script</strong> we added to this starter:</p>\n<pre><code>GITHUB_USER=your-username GITHUB_REPO=your-repo GITHUB_AUTH_TOKEN=your-auth-token trigger-github-deploy-action.sh\n</code></pre>\n<p>Here's how you can get an <a href=\"https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token\">auth token</a>.</p>\n<p>This situation is definitely not ideal, and can be solved with Ghost plugins, but we wanted to stick to the basic install.</p>\n<h2 id=\"showyoursupport\">üôè¬†¬†Show your support</h2>\n<p>Please <a href=\"https://github.com/fission-suite/nextjs-blog-starter-typescript-ghost\">give a¬†¬†‚≠êÔ∏è</a>¬†¬†if you liked this project! We appreciate it :)</p>\n<!--kg-card-end: markdown--><h3></h3>","url":"https://blog.fission.codes/headless-ghost-blog-fission/","canonical_url":null,"uuid":"7e883b34-c739-4a41-a751-d695e25aa927","page":false,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"60210daa2dc76c001e5a3301","reading_time":null}},{"node":{"id":"Ghost__Post__5ea068b333f762001e6c6fae","title":"Experimenting with HLS Video Streaming and IPFS","slug":"experimenting-with-hls-video-streaming-and-ipfs","featured":false,"feature_image":"https://images.unsplash.com/photo-1501141178950-e7fa06e4adf5?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"Walk through of encoding video using HTTP Live Streaming (HLS) and publishing to Fission.","custom_excerpt":"Walk through of encoding video using HTTP Live Streaming (HLS) and publishing to Fission.","created_at_pretty":"22 April, 2020","published_at_pretty":"22 April, 2020","updated_at_pretty":"22 April, 2020","created_at":"2020-04-22T08:54:27.000-07:00","published_at":"2020-04-22T10:09:39.000-07:00","updated_at":"2020-04-22T10:09:39.000-07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Boris Mann","slug":"boris","bio":"Hand-waving web tinkerer who cares about open source and the decentralized web. Cooks & eats.","profile_image":"https://s3.fission.codes/2019/05/5A4DF670-6003-4612-B06B-A9DA17C6D6F3.jpeg","twitter":"@bmann","facebook":null,"website":"https://blog.bmannconsulting.com"}],"primary_author":{"name":"Boris Mann","slug":"boris","bio":"Hand-waving web tinkerer who cares about open source and the decentralized web. Cooks & eats.","profile_image":"https://s3.fission.codes/2019/05/5A4DF670-6003-4612-B06B-A9DA17C6D6F3.jpeg","twitter":"@bmann","facebook":null,"website":"https://blog.bmannconsulting.com"},"primary_tag":{"name":"How To","slug":"how-to","description":null,"feature_image":null,"meta_description":null,"meta_title":null},"tags":[{"name":"How To","slug":"how-to","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"IPFS","slug":"ipfs","description":"InterPlanetary File System","feature_image":null,"meta_description":null,"meta_title":null},{"name":"HLS","slug":"hls","description":null,"feature_image":null,"meta_description":null,"meta_title":null}],"plaintext":"We've been running weekly developer lunch & learn sessions\n[https://talk.fission.codes/c/events/dweblunchnlearn/27]  over video. I've been\ndownloading the video from Zoom, doing some basic trimming, and then uploading\nit using Fission, and embedding the IPFS link in our Discourse forum. This works\npretty well ‚Äì Discourse recognizes the video file extension and embeds a video\nplayer in the post automatically. I had read a bit about HTTP Live Streaming\n(HLS) and wanted to experiment.\n\nOriginally developed by Apple, and now widely supported, HLS doesn't need any\nspecial server-side support. A bit more in this freeCodeCamp article:\n\n> The most important feature of HLS is its ability to adapt the bitrate of the\nvideo to the actual speed of the connection. This optimizes the quality of the\nexperience.\n\nHLS videos are encoded in different renditions at different resolutions and\nbitrates. This is usually referred to as the bitrate ladder. When a connection\ngets slower, the protocol automatically adjusts the requested bitrate to the\nbandwidth available.\n\n‚Äì freeCodeCamp: HLS Video Streaming: What it is, and When to Use it\n[https://www.freecodecamp.org/news/what-is-hls-and-when-to-use-it/]\nThere's an example in the JavaScript implementation of IPFS about using HLS\nwith\njs-ipfs\n[https://github.com/ipfs/js-ipfs/tree/master/examples/browser-video-streaming].\nThe README explains:\n\n> The fact that HLS content is just \"a bunch of files\" makes it a good choice for\nIPFS (another protocol that works this way is MPEG-DASH, which could certainly\nbe a good choice as well). Furthermore, the hls.js\n[https://github.com/video-dev/hls.js]  library enables straightforward\nintegration with the HTML5 video element.\n\"Just a bunch of files\" is pretty much how we're thinking about Fission. Fission\nand any standard IPFS gateway serves up files over HTTP and/or natively with\nIPFS, without plugins, in any browser. It's really great to get back to what is\nbasically the 2020 equivalent of upload files to the server.\n\nI took the latest video file of Joel talking about Ceramic Network\n[https://talk.fission.codes/t/ceramic-network-technical-discussion-with-joel-thorstensson-cto-of-3box/559] \n and ran the ffmpeg  command from the js-ipfs example. On MacOS, brew install\nffmpeg  will get you the program.\n\nffmpeg -i ../YOURVIDEO.mp4 -profile:v baseline -level 3.0 -start_number 0\n-hls_time 5 -hls_list_size 0 -f hls master.m3u8\n\nOn my desktop iMac, the progress showed to be encoding at 4x - 5x speed. The\nvideo is about an hour, so it took about 20 minutes to complete. The output is\n400+ files, which I uploaded with fission up  and then noted down the hash of\nthe folder.\n\nBrowse the files on IPFS using Fission Drive\n[https://drive.fission.codes/#/QmYGs1ksGX3eMiGvxNuvRT6PD7zPKZpHyiUDXKGQoL4R7S]\nThen I went back and edited the streaming.js  folder and index.html. The \nstreaming.js  file just needs the hash of the folder that contains the\nHLS-encoded video, which for this video is \nQmYGs1ksGX3eMiGvxNuvRT6PD7zPKZpHyiUDXKGQoL4R7S. Feel free to use this to\nexperiment with! I kept the master.m3u8  file name so didn't need to change\nthat.\n\nOne change I made was to to also include the IPFS script from a CDN in the \nindex.html  file (the js-ipfs example assumes you're running things locally and\nworking with js-ipfs from there). Just add this line:\n\n<script src=\"https://cdn.jsdelivr.net/npm/ipfs/dist/index.min.js\"></script>\n\nYou can browse all the files directly using Fission Drive\n[https://drive.fission.codes/#/events.fission.name/2020/04-16-dweb-lunchnlearn-joel-ceramic-network]\n, including the source video that was encoded. Visiting the index page\n[https://events.fission.name/2020/04-16-dweb-lunchnlearn-joel-ceramic-network/] \nwill load the player and HLS stream the video.\n\nExample HLS Video\nHere's the source and video embedded via Codepen ‚Äì hit the HTML button to view\nsource. Note the Fission gateway link to the published version of the \nstreaming.js  file, also remotely included:\n\nThe video isn't very high quality to begin with, and adding width/height to the\nvideo element could constrain it to different sizes.\n\nMore about Joel and Ceramic Network on the forum event page ¬ª\n[https://talk.fission.codes/t/ceramic-network-technical-discussion-with-joel-thorstensson-cto-of-3box/559]\n\nConclusion\nThis is a very manual process, and there are lots of dedicated video encoding\nservices. It was a good experiment to see that anything that is a \"bunch of\nfiles\" can just work over the distributed IPFS network, and easily published and\nhosted on Fission.\n\nExperimenting with a large, high quality video and testing across different\ndevices and network speeds (and whether or not nearby peers had a copy of the\nvideo) would need to be done vs. just embedding the original video to see what\nthe user experience is actually like.\n\nThis also leads to some interesting thoughts about distributed encoding. Once an\noriginal video is encoded and added to the network by one person, it never needs\nto be encoded again. From some brief research, ffmpeg is not deterministic,\nwhich lead to this thread on Mastodon\n[https://mastodon.social/@Gargron/11088922]. This means that different people\nencoding a video could get different output files, which means different hashes\nin IPFS.\n\nHowever, the original video file is unique, so adding metadata to the original\nsource video file for discovery of the unique, permanent hash of an HLS-encoded\nversion could work.\n\nWe're currently doing some work on how to do this for images, so that different\nsizes are automatically available and cached in the network.\n\n\n--------------------------------------------------------------------------------\n\nFission is an app & web hosting platform that implements a web native file\nsystem powered by IPFS. Build and run locally, fission up  to host everywhere. \nRead our guide [https://guide.fission.codes]  to get started and sign up right\nfrom the command line.","html":"<p>We've been running <a href=\"https://talk.fission.codes/c/events/dweblunchnlearn/27\">weekly developer lunch &amp; learn sessions</a> over video. I've been downloading the video from Zoom, doing some basic trimming, and then uploading it using Fission, and embedding the IPFS link in our Discourse forum. This works pretty well ‚Äì Discourse recognizes the video file extension and embeds a video player in the post automatically. I had read a bit about HTTP Live Streaming (HLS) and wanted to experiment.</p><p>Originally developed by Apple, and now widely supported, HLS doesn't need any special server-side support. A bit more in this freeCodeCamp article:</p><blockquote>The most important feature of HLS is its ability to adapt the bitrate of the video to the actual speed of the connection. This optimizes the quality of the experience.<br><br>HLS videos are encoded in different renditions at different resolutions and bitrates. This is usually referred to as the bitrate ladder. When a connection gets slower, the protocol automatically adjusts the requested bitrate to the bandwidth available.<br><br>‚Äì <a href=\"https://www.freecodecamp.org/news/what-is-hls-and-when-to-use-it/\">freeCodeCamp: HLS Video Streaming: What it is, and When to Use it</a></blockquote><p>There's an <a href=\"https://github.com/ipfs/js-ipfs/tree/master/examples/browser-video-streaming\">example in the JavaScript implementation of IPFS about using HLS with js-ipfs</a>. The README explains:</p><blockquote>The fact that HLS content is just \"a bunch of files\" makes it a good choice for IPFS (another protocol that works this way is MPEG-DASH, which could certainly be a good choice as well). Furthermore, the <a href=\"https://github.com/video-dev/hls.js\">hls.js</a> library enables straightforward integration with the HTML5 video element.</blockquote><p>\"Just a bunch of files\" is pretty much how we're thinking about Fission. Fission and any standard IPFS gateway serves up files over HTTP and/or natively with IPFS, without plugins, in any browser. It's really great to get back to what is basically the 2020 equivalent of upload files to the server.</p><p>I took the latest video file of <a href=\"https://talk.fission.codes/t/ceramic-network-technical-discussion-with-joel-thorstensson-cto-of-3box/559\">Joel talking about Ceramic Network</a> and ran the <code>ffmpeg</code> command from the js-ipfs example. On MacOS, <code>brew install ffmpeg</code> will get you the program.</p><p><code>ffmpeg -i ../YOURVIDEO.mp4 -profile:v baseline -level 3.0 -start_number 0 -hls_time 5 -hls_list_size 0 -f hls master.m3u8</code></p><p>On my desktop iMac, the progress showed to be encoding at 4x - 5x speed. The video is about an hour, so it took about 20 minutes to complete. The output is 400+ files, which I uploaded with <code>fission up</code> and then noted down the hash of the folder.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://s3.fission.codes/2020/04/hls-video-files-in-drive-600.png\" class=\"kg-image\"><figcaption>Browse the <a href=\"https://drive.fission.codes/#/QmYGs1ksGX3eMiGvxNuvRT6PD7zPKZpHyiUDXKGQoL4R7S\">files on IPFS using Fission Drive</a></figcaption></figure><!--kg-card-end: image--><p>Then I went back and edited the <code>streaming.js</code> folder and <code>index.html</code>. The <code>streaming.js</code> file just needs the hash of the folder that contains the HLS-encoded video, which for this video is <code>QmYGs1ksGX3eMiGvxNuvRT6PD7zPKZpHyiUDXKGQoL4R7S</code>. Feel free to use this to experiment with! I kept the <code>master.m3u8</code> file name so didn't need to change that.</p><p>One change I made was to to also include the IPFS script from a CDN in the <code>index.html</code> file (the js-ipfs example assumes you're running things locally and working with js-ipfs from there). Just add this line:</p><p><code>&lt;script src=\"https://cdn.jsdelivr.net/npm/ipfs/dist/index.min.js\"&gt;&lt;/script&gt;</code></p><p>You can <a href=\"https://drive.fission.codes/#/events.fission.name/2020/04-16-dweb-lunchnlearn-joel-ceramic-network\">browse all the files directly using Fission Drive</a>, including the source video that was encoded. <a href=\"https://events.fission.name/2020/04-16-dweb-lunchnlearn-joel-ceramic-network/\">Visiting the index page</a> will load the player and HLS stream the video.</p><h2 id=\"example-hls-video\">Example HLS Video</h2><p>Here's the source and video embedded via Codepen ‚Äì hit the HTML button to view source. Note the Fission gateway link to the published version of the <code>streaming.js</code> file, also remotely included:</p><!--kg-card-begin: embed--><figure class=\"kg-card kg-embed-card\"><iframe id=\"cp_embed_GRprJoZ\" src=\"https://codepen.io/borismann/embed/preview/GRprJoZ?height=300&amp;slug-hash=GRprJoZ&amp;default-tabs=html,result&amp;host=https://codepen.io\" title=\"HLS Streaming over IPFS Example\" scrolling=\"no\" frameborder=\"0\" height=\"300\" allowtransparency=\"true\" class=\"cp_embed_iframe\" style=\"width: 100%; overflow: hidden;\"></iframe></figure><!--kg-card-end: embed--><p>The video isn't very high quality to begin with, and adding width/height to the video element could constrain it to different sizes.</p><p>More about <a href=\"https://talk.fission.codes/t/ceramic-network-technical-discussion-with-joel-thorstensson-cto-of-3box/559\">Joel and Ceramic Network on the forum event page ¬ª</a></p><h2 id=\"conclusion\">Conclusion</h2><p>This is a very manual process, and there are lots of dedicated video encoding services. It was a good experiment to see that anything that is a \"bunch of files\" can just work over the distributed IPFS network, and easily published and hosted on Fission.</p><p>Experimenting with a large, high quality video and testing across different devices and network speeds (and whether or not nearby peers had a copy of the video) would need to be done vs. just embedding the original video to see what the user experience is actually like.</p><p>This also leads to some interesting thoughts about distributed encoding. Once an original video is encoded and added to the network by one person, it never needs to be encoded again. From some brief research, <a href=\"https://mastodon.social/@Gargron/11088922\">ffmpeg is not deterministic, which lead to this thread on Mastodon</a>. This means that different people encoding a video could get different output files, which means different hashes in IPFS.</p><p>However, the original video file is unique, so adding metadata to the original source video file for discovery of the unique, permanent hash of an HLS-encoded version could work.</p><p>We're currently doing some work on how to do this for images, so that different sizes are automatically available and cached in the network.</p><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><p><em>Fission is an app &amp; web hosting platform that implements a web native file system powered by IPFS. Build and run locally, <code>fission up</code> to host everywhere. <a href=\"https://guide.fission.codes\">Read our guide</a> to get started and sign up right from the command line.</em></p>","url":"https://blog.fission.codes/experimenting-with-hls-video-streaming-and-ipfs/","canonical_url":null,"uuid":"a59c1236-5ed1-4fda-8b61-e88a76aca80c","page":false,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ea068b333f762001e6c6fae","reading_time":null}},{"node":{"id":"Ghost__Post__5dc7cad72c7d24001ef7ff16","title":"Exporting your Facebook photos to Fission","slug":"exporting-your-facebook-photos-to-fission","featured":false,"feature_image":"https://images.unsplash.com/photo-1522159698025-071104a1ddbd?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"A quick how-to on getting the Facebook export of your photos and videos, and then hosting them on Fission.","custom_excerpt":"A quick how-to on getting the Facebook export of your photos and videos, and then hosting them on Fission.","created_at_pretty":"10 November, 2019","published_at_pretty":"10 November, 2019","updated_at_pretty":"10 November, 2019","created_at":"2019-11-10T00:31:19.000-08:00","published_at":"2019-11-10T01:01:10.000-08:00","updated_at":"2019-11-10T01:01:10.000-08:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Boris Mann","slug":"boris","bio":"Hand-waving web tinkerer who cares about open source and the decentralized web. Cooks & eats.","profile_image":"https://s3.fission.codes/2019/05/5A4DF670-6003-4612-B06B-A9DA17C6D6F3.jpeg","twitter":"@bmann","facebook":null,"website":"https://blog.bmannconsulting.com"}],"primary_author":{"name":"Boris Mann","slug":"boris","bio":"Hand-waving web tinkerer who cares about open source and the decentralized web. Cooks & eats.","profile_image":"https://s3.fission.codes/2019/05/5A4DF670-6003-4612-B06B-A9DA17C6D6F3.jpeg","twitter":"@bmann","facebook":null,"website":"https://blog.bmannconsulting.com"},"primary_tag":{"name":"How To","slug":"how-to","description":null,"feature_image":null,"meta_description":null,"meta_title":null},"tags":[{"name":"How To","slug":"how-to","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"Facebook","slug":"facebook","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"photos","slug":"photos","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"videos","slug":"videos","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"IPFS","slug":"ipfs","description":"InterPlanetary File System","feature_image":null,"meta_description":null,"meta_title":null}],"plaintext":"Facebook has a fairly extensive data export system built in. I decided to export\nmy photos and videos and put them up on Fission.\n\nFor now, this is a manual process and involves some command line usage. I'll\nwrite this up as an App Idea in our forum\n[https://talk.fission.codes/c/app-ideas]  and see if we can spend some time\nmaking this \"one-click\".\n\n> Please make that one click for me dude\n\n‚Äî Jamie Burke (@jamie247) November 9, 2019\n[https://twitter.com/jamie247/status/1193083841826770944?ref_src=twsrc%5Etfw]\nRead the Facebook help article on Accessing & Downloading Your Information\n[https://www.facebook.com/help/1701730696756992/]  for instructions on how to\nnavigate to the right section of your Facebook account.\n\nOn a desktop browser, it should be under the triangle in the upper right hand\ncorner, then Settings, then Your Facebook Information, then Download Your\nInformation.\n\nI don't upload much to Facebook and only cross-post my Instagram photos (which\nare cross-posted to my personal blog), so I clicked Deselect All  (says Select\nAll  in the screenshot above), and only selected Photos and Videos. I also set\nMedia Quality to \"High\" (although some people still report that these are still\nnot as large as the originals, which may only be accessible through the API).\n\nYou can experiment with including other items. But, be aware that because there\naren't any permissions, you may be sharing information you don't want to if you\npublish the files. Same goes for the photos. I have posted most things on\nFacebook the assumption that they are \"public\".\n\nClick the Create File  button and go make a coffee. Facebook will notify when\nyour download is ready.\n\nJust over 13 years of Facebook.To download, you'll need to click on the Download  button and enter your\nFacebook password. You now have a zip file with browse-able HTML files and your\nphoto and video files.\n\nPutting your files online with Fission\nYou'll need to type a few commands into the command line Terminal on your\nmachine, but everything should just work if you copy-paste.\n\nInstall the IPFS Desktop [https://github.com/ipfs-shipyard/ipfs-desktop#install] \n and run it. You've got a graphical interface to explore your local IPFS server,\nwhich is running in the background.\n\nOn Mac, make sure you've got homebrew installed [https://brew.sh], then open the\nTerminal app and install the Fission tools using these commands:\n\nbrew tap fission-suite/fission\nbrew install fission-cli\n\nYou can find extended installation instructions in our Fission Guide\n[https://guide.fission.codes/installation], and I expect our friends running\nLinux will have no problem.\n\nNow, you're going to register for Fission.\n\nfission register\n\nYour username will be your subdomain, e.g. boris.fission.name. Pick a password\nand enter an email address. We are adding support for custom domain names, stay\ntuned!\n\nNow, you've got a zip file in your Downloads folder from Facebook, called\nsomething like \"facebook-YOURNAME.zip\". Unzip it and you'll have a\n\"facebook-YOURNAME\" folder.\n\nBack to the terminal! This is the last step!\n\nThe fission up  command is going to add all your files to IPFS, through your\nlocal IPFS Desktop. Then, Fission's server will get sent the hash that\nrepresents the folder, we'll use IPFS to keep a copy of all your files, and\nupdate DNS of your subdomain.\n\nThe following command will be correct if you're on a Mac and downloaded to the\nstandard downloads folder. Otherwise, just enter the path to where the unzipped\nFacebook folder is:\n\nfission up ~/Downloads/facebook-YOURNAME/\n\nI only had about 200MB of files, so this happened pretty quickly. Visit\nYOURNAME.fission.name in your browser and you should see something like this:\n\nYour Facebook photos are online and browse-able! You can see mine at \nboris.fission.name/Photos/facebook [https://boris.fission.name/Photos/facebook/] \n (I put mine in a subfolder, because I already host a bunch of public files on\nmy Fission site).\n\nTechnically the files are being served directly from your computer, when you're\nonline and have IPFS Desktop running. The Fission service is also serving those\nfiles, and stays online when you're offline. As a next step, you can explore\ninstalling the IPFS Companion browser extension\n[https://github.com/ipfs-shipyard/ipfs-companion]  which will access IPFS\ncontent natively.\n\nJoin us in our Discord chat forum [https://fission.codes/discord]  if you have\nquestions or just come say \"hi\"!","html":"<p>Facebook has a fairly extensive data export system built in. I decided to export my photos and videos and put them up on Fission.</p><p>For now, this is a manual process and involves some command line usage. I'll write this up as an <a href=\"https://talk.fission.codes/c/app-ideas\">App Idea in our forum</a> and see if we can spend some time making this \"one-click\".</p><!--kg-card-begin: embed--><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Please make that one click for me dude</p>&mdash; Jamie Burke (@jamie247) <a href=\"https://twitter.com/jamie247/status/1193083841826770944?ref_src=twsrc%5Etfw\">November 9, 2019</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</figure><!--kg-card-end: embed--><p>Read the Facebook help article on <a href=\"https://www.facebook.com/help/1701730696756992/\">Accessing &amp; Downloading Your Information</a> for instructions on how to navigate to the right section of your Facebook account.</p><p>On a desktop browser, it should be under the triangle in the upper right hand corner, then <em>Settings</em>, then <em>Your Facebook Information</em>, then <em>Download Your Information</em>.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card\"><img src=\"https://s3.fission.codes/2019/11/Screenshot-2019-11-09-at-8.29.37-AM-1.png\" class=\"kg-image\"></figure><!--kg-card-end: image--><p>I don't upload much to Facebook and only cross-post my Instagram photos (which are cross-posted to my personal blog), so I clicked <em>Deselect All</em> (says <em>Select All</em> in the screenshot above), and only selected Photos and Videos. I also set Media Quality to \"High\" (although some people still report that these are still not as large as the originals, which may only be accessible through the API).</p><p>You can experiment with including other items. But, be aware that because there aren't any permissions, you may be sharing information you don't want to if you publish the files. Same goes for the photos. I have posted most things on Facebook the assumption that they are \"public\".</p><p>Click the <em>Create File</em> button and go make a coffee. Facebook will notify when your download is ready.</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://s3.fission.codes/2019/11/Screenshot-2019-11-09-at-8.38.38-AM-1.png\" class=\"kg-image\"><figcaption>Just over 13 years of Facebook.</figcaption></figure><!--kg-card-end: image--><p>To download, you'll need to click on the <em>Download</em> button and enter your Facebook password. You now have a zip file with browse-able HTML files and your photo and video files.</p><h2 id=\"putting-your-files-online-with-fission\">Putting your files online with Fission</h2><p>You'll need to type a few commands into the command line Terminal on your machine, but everything should just work if you copy-paste.</p><p><a href=\"https://github.com/ipfs-shipyard/ipfs-desktop#install\">Install the IPFS Desktop</a> and run it. You've got a graphical interface to explore your local IPFS server, which is running in the background.</p><p>On Mac, make sure you've got <a href=\"https://brew.sh\">homebrew installed</a>, then open the Terminal app and install the Fission tools using these commands:</p><!--kg-card-begin: code--><pre><code class=\"language-bash\">brew tap fission-suite/fission\nbrew install fission-cli</code></pre><!--kg-card-end: code--><p>You can find extended <a href=\"https://guide.fission.codes/installation\">installation instructions in our Fission Guide</a>, and I expect our friends running Linux will have no problem.</p><p>Now, you're going to register for Fission.</p><!--kg-card-begin: code--><pre><code class=\"language-bash\">fission register</code></pre><!--kg-card-end: code--><p>Your username will be your subdomain, e.g. <code>boris.fission.name</code>. Pick a password and enter an email address. We are adding support for custom domain names, stay tuned!</p><p>Now, you've got a zip file in your Downloads folder from Facebook, called something like \"facebook-YOURNAME.zip\". Unzip it and you'll have a \"facebook-YOURNAME\" folder.</p><p>Back to the terminal! This is the last step!</p><p>The <code>fission up</code> command is going to add all your files to IPFS, through your local IPFS Desktop. Then, Fission's server will get sent the hash that represents the folder, we'll use IPFS to keep a copy of all your files, and update DNS of your subdomain.</p><p>The following command will be correct if you're on a Mac and downloaded to the standard downloads folder. Otherwise, just enter the path to where the unzipped Facebook folder is:</p><!--kg-card-begin: code--><pre><code class=\"language-bash\">fission up ~/Downloads/facebook-YOURNAME/</code></pre><!--kg-card-end: code--><p>I only had about 200MB of files, so this happened pretty quickly. Visit YOURNAME.fission.name in your browser and you should see something like this:</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card\"><img src=\"https://s3.fission.codes/2019/11/Screenshot-2019-11-09-at-9.33.57-AM-1.png\" class=\"kg-image\"></figure><!--kg-card-end: image--><p>Your Facebook photos are online and browse-able! You can see mine at <a href=\"https://boris.fission.name/Photos/facebook/\">boris.fission.name/Photos/facebook</a> (I put mine in a subfolder, because I already host a bunch of public files on my Fission site).</p><p>Technically the files are being served directly from your computer, when you're online and have IPFS Desktop running. The Fission service is also serving those files, and stays online when you're offline. As a next step, you can explore installing the <a href=\"https://github.com/ipfs-shipyard/ipfs-companion\">IPFS Companion browser extension</a> which will access IPFS content natively.</p><p>Join us in our <a href=\"https://fission.codes/discord\">Discord chat forum</a> if you have questions or just come say \"hi\"!</p>","url":"https://blog.fission.codes/exporting-your-facebook-photos-to-fission/","canonical_url":null,"uuid":"74f42f87-7308-45b9-8e73-7b42dc192d6e","page":false,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5dc7cad72c7d24001ef7ff16","reading_time":null}}]}},"pageContext":{"slug":"how-to","pageNumber":0,"humanPageNumber":1,"skip":0,"limit":12,"numberOfPages":1,"previousPagePath":"","nextPagePath":""}},"staticQueryHashes":["1752937443","2358152166","2561578252","2731221146","4145280475"]}