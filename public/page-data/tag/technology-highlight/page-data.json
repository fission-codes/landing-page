{"componentChunkName":"component---src-templates-tag-js","path":"/tag/technology-highlight/","result":{"data":{"ghostTag":{"slug":"technology-highlight","name":"Technology Highlight","feature_image":null,"description":null,"meta_title":null,"meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5eb19b7a82ce80001ee86716","title":"UCAN: Authorizing Users Without a Back End","slug":"auth-without-backend","featured":true,"feature_image":"https://s3.fission.codes/2020/05/zdenek-machacek-EtxsgEcHnZg-unsplash.jpg","excerpt":"User Controlled Authorization Networks (UCANs) are a way of doing authorization (\"what you can do\") where users are fully in control.","custom_excerpt":"User Controlled Authorization Networks (UCANs) are a way of doing authorization (\"what you can do\") where users are fully in control.","created_at_pretty":"05 May, 2020","published_at_pretty":"07 May, 2020","updated_at_pretty":"26 May, 2020","created_at":"2020-05-05T09:59:38.000-07:00","published_at":"2020-05-07T12:23:57.000-07:00","updated_at":"2020-05-26T15:19:05.000-07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Brooklyn Zelenka","slug":"expede","bio":"CTO at Fission ‚ô•Œª Programs with functions","profile_image":"https://s3.fission.codes/2019/05/IMG_2934-square.jpeg","twitter":"@expede","facebook":null,"website":null}],"primary_author":{"name":"Brooklyn Zelenka","slug":"expede","bio":"CTO at Fission ‚ô•Œª Programs with functions","profile_image":"https://s3.fission.codes/2019/05/IMG_2934-square.jpeg","twitter":"@expede","facebook":null,"website":null},"primary_tag":{"name":"Technology Highlight","slug":"technology-highlight","description":null,"feature_image":null,"meta_description":null,"meta_title":null},"tags":[{"name":"Technology Highlight","slug":"technology-highlight","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"ucan","slug":"ucan","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"auth","slug":"auth","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"authorization","slug":"authorization","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"jwt","slug":"jwt","description":null,"feature_image":null,"meta_description":null,"meta_title":null}],"plaintext":"Fission is building a system which \"makes the right thing the easy thing.\" It\nlets you write apps for the browser without having to write or deploy a back\nend. We're making use of fairly recent browser features and W3C standards to\nmake this all possible. Read on for a technical summary, or join us in the\ndeveloper forum [https://talk.fission.codes]  to get into more detail.\n\nOne of the most common tasks for apps is authorizing users to perform some\naction, like storing new data to storage, updating records, or fetching a file. \n\nTraditional app architecture has many users share one database (\"multi-tenant\"),\nwith all user data fully interleaved with each other. Authorization here is\nprimarily focused on keeping users from editing each other's records on this\nshared infrastructure. The server's rules give fairly coarse-grained control.\nDue to the inevitable exceptions to these rules, the logic becomes increasingly\ncomplex over time.\n\nEven in a microservice architecture, typically all requests are funneled through\na central authorization service. Over time this causes several challenges,\nincluding complex logic, cost of maintenance, tricky edge cases, and difficulty\nmanaging traffic spikes. In short: it doesn't scale well.\n\nEven incumbents like  Google are moving away from the traditional auth server\nmodel [https://research.google/pubs/pub41892/]  to overcome the above\nchallenges. Fission has different constraints from Google and Amazon, but can\nadapt a lot of these ideas for our purposes. Essentially they're moving from a\ncentral auth server setup to a distributed model where more power is delegated\nto services.\n\nWhat if we learn from Google's approach (plus older approaches like SDSI/SPKI\n[https://tools.ietf.org/html/rfc2693]) but took it to its logic conclusion?\n\nIntroducing UCANs\n> User Controlled Authorization Networks (UCANs) are a way of doing authorization\nwhere users are fully in control. OAuth is designed for a centralized world,\nUCAN is the distributed user controlled version.\nUCAN SamAt a high level, User Controlled Authorization Networks (UCANs) are a\nway of doing authorization (\"what you can  do\") where users are fully in\ncontrol. There's no all-powerful authorization server, or server of any kind\nrequired. Everything that a users is allowed to do is captured directly in a key\nor token, and can be sent to anyone that knows how to interpret this format.\n\nSince all Fission accounts are equipped with a global ID and cryptographic keys,\nwe were able to design a system that has very few assumptions and thus works in\na huge number of situations.\n\nThis setup has several advantages:\n\n 1. Low effort:¬†developers don't need to write and maintain complex access logic\n 2. Familiar:¬†uses very common JSON Web Tokens (JWTs)\n 3. Invisible: users don't need to know that anything special is happening\n 4. Flexible: access can be granted as coarse or granular as the end users wants\n 5. Scalable: no auth server bottleneck / scales infinitely\n 6. Secure:¬†military-grade encryption\n 7. Collaborative:¬†users and services and delegate a subset of their access to\n    others\n 8. Self-contained: the token contains all the information needed to verify it\n\nUCANs are all that we need to sign into multiple machines, delegate access for\nservice providers to do things while we're offline, securely collaborate on\ndocuments with a team, and more. We get the flexibility of fine- or\ncoarse-grained control, all controlled by the one who cares about the data the\nmost: the user.\n\nWe've implemented this as the authorization system for Fission, and are also\nmaking this available as a building block for developers to solve user\nauthorization and delegation within their own applications.\n\n\n--------------------------------------------------------------------------------\n\nThis system of authorization is broken into two halves: read and write (or\n\"command and query\", depending on your background). Without getting too in the\nweeds, here's a high level description of how this all works:\n\nRead (Query) Access\nRead access comes in three flavours: public, private, and unlisted. Access\nfollows the object-capability model\n[https://en.wikipedia.org/wiki/Object-capability_model?oldformat=true], where\nanyone with the reference (URL or CID) and cryptograhic key can read the data by\nvirtue of having access to these.\n\nPublic üëÄ\nPublic files are just that: files that can be discovered or accessed by anyone\nat an easy-to read path.\n\nHere's a live example: https://boris.fission.name/Photos/boris-with-icecream.jpg\n\nPrivate üîê\nThe user encrypts the data, and shares the key with those that should have\naccess. The contents of a private directory is only readable with a key, but\nonce you have access to that directory, all of the data in that directory\n(including subdirectories and metadata) is accessible.\n\nThe end experience matches the behaviour in other online consumer file storage\nsolutions like Dropbox and Google Drive. A major difference with Fission is that\nthe end user is given complete control over who has access, and access does not\ndepend on Fission's servers being accessible (i.e. you're offline or Fission\ndisappears).\n\nUnlisted üó∫Ô∏è\nSort of a mashup of public and private files! This is useful when you want to\n(e.g.) embed an image in an email without distributing keys, but also don't want\nit easily discoverable.\n\nThe unlisted files themselves are left unencrypted, but finding them is\npractically infeasible without the private index. Think of this index as a\nsecret treasure map for the web ‚Äî the map itself private (only a select few have\nthe map), but anyone with it can find the data at the marked locations.\n\nUnder the hood, the Fission SDK creates a JSON file that lists all of the\nlocations. That JSON file is then encrypted and the key passed to whoever should\nhave access., or the links can be shared directly.\n\nHere's a simple example of what this looks like:\n\n// The \"treasure map\"\n{\n  \"QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ\": {\n      \"cat.jpg\": \"Qmd286K6pohQcTKYqnS1YhWrCiS4gz7Xi34sdwMe9USZ7u\"\n  }\n}\n\n# URL\nhttps://ipfs.runfission.com/ipfs/QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ/cat.jpg\n\nWrite (Command) Access üñäÔ∏è\nThere are some actions that a user needs the help of another user or service to\nperform. For example: sending an email, or updating DNS.\n\nIn a traditional OAuth based system, the \"account\" lives entirely on the server,\nand the user is granted access with a token. In Fission's design, the account is\na key pair, and a UCAN is equivalent to an OAuth token. OAuth is designed for a\ncentralized client/server world. UCANs are the distributed user controlled\nequivalent.\n\nUCANs are simply JWT [jwt.io]s that contain special keys. Much of this will look\nfamiliar if you've done web auth in the past decade or so. Here's an example:\n\n{\n  \"alg\": \"Ed25519\",\n  \"typ\": \"JWT\"\n  \"uav\": \"0.1.0\"\n}\n{\n  \"aud\": \"did:key:zStEZpzSMtTt9k2vszgvCwF4fLQQSyA15W5AQ4z3AR6Bx4eFJ5crJFbuGxKmbma4\",\n  \"iss\": \"did:key:z5C4fuP2DDJChhMBCwAkpYUMuJZdNWWH5NeYjUyY8btYfzDh3aHwT5picHr9Ttjq\",\n  \"nbf\": 1588713622,\n  \"exp\": 1589000000,\n  \"scp\": \"/\"\n  \"ptc\": \"APPEND\",\n  \"prf\": null,\n}\n\nExample UCAN JSON Web TokenBearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsInVhdiI6IjAuMS4wIn0.eyJhdWQiOiJkaW\nQ6a2V5OnpTdEVacHpTTXRUdDlrMnZzemd2Q3dGNGZMUVFTeUExNVc1QVE0ejNBUjZCeDRl\nRko1Y3JKRmJ1R3hLbWJtYTQiLCJpc3MiOiJkaWQ6a2V5Ono1QzRmdVAyRERKQ2hoTUJDd0\nFrcFlVTXVKWmROV1dINU5lWWpVeVk4YnRZZnpEaDNhSHdUNXBpY0hyOVR0anEiLCJuYmYi\nOjE1ODg3MTM2MjIsImV4cCI6MTU4OTAwMDAwMCwic2NwIjoiLyIsInB0YyI6IkFQUEVORC\nIsInByZiI6bnVsbH0.Ay8C5ajYWHxtD8y0msla5IJ8VFffTHgVq448Hlr818JtNaTUzNIw\nFiuutEMECGTy69hV9Xu9bxGxTe0TpC7AzV34p0wSFax075mC3w9JYB8yqck_MEBg_dZ1xl\nJCfDve60AHseKPtbr2emp6hZVfTpQGZzusstimAxyYPrQUWv9wqTFmin0Ls-loAWamleUZ\noE1Tarlp_0h9SeV614RfRTC0e3x_VP9Ra_84JhJHZ7kiLf44TnyPl_9AbzuMdDwCvu-zX\njd_jMlDyYcuwamJ15XqrgykLOm0WTREgr_sNLVciXBXd6EQ-Zh2L7hd38noJm1P_MIr9_\nEDRWAhoRLXPQ\n\nThe same, as a bearer token (for an HTTP Authorization  header)Let's break that\ndown:\n\nHeader üìã\nThis is a standard JWT header, plus a uav  field.\n\n * alg  ‚Äî type of signature\n * typ  ‚Äî¬†state that this is a JWT\n * uav  ‚Äî \"UCAN version\" (so we can track the format of when it was issued)\n\nBody üí™\n * aud  \"Audience\" ‚Äî¬†the ID of who it's intended for (the \"to\" field)\n * iss  \"Issuer\" ‚Äî¬†ID of who sent it (the \"from\" field)\n * nbf  \"Not Before\" ‚Äî¬†Unix timestamp of when it becomes valid (typically when\n   it was created, but not always)\n * exp  \"Expiry\" ‚Äî¬†Unix timestamp of when it stops being valid\n * scp  \"Scope\" ‚Äî¬†The scope of things it's able to change (e.g. a file system\n   path)\n * ptc  \"Potency\" ‚Äî what rights comes with the token (in this case it's append\n   only)\n * prf  \"Proof\" ‚Äî an optional nested token with equal or greater privileges\n\nThese are then all signed with the user's private key. This key must match the\npublic key in the iss  field (user IDs are public keys), directly authenticating\nthe token. As the token is a complete description of access, this token is\nself-validating with no need to look at other data or services.\n\nDelegation ü§ù\nWhat if you want to grant another user or service the ability to perform some\naction on your behalf? As long as they have a valid UCAN, they can wrap it in\nanother with equal or lesser rights and include the original in the prf  field.\n\nSince every UCAN layer is self-signed, we can trace back to the root (no prf \nfield), and know who the delegate is acting as. This chain of tokens is itself\nis the proof that you're perform some action.\n\nFor example, here's a chain:\n\n\"prf\":\"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\n       eyJhdWQiOiJkaWQ6a2V5OnpTdEVacHpTTXRUdDlrMnZz\n       emd2Q3dGNGZMUVFTeUExNVc1QVE0ejNBUjZCeDRlRko1\n       Y3JKRmJ1R3hLbWJtYTQiLCJleHAiOjE1ODgyNjU0MjAs\n       ImlzcyI6ImRpZDprZXk6ejFMQm53RWt0d1lMcnBQaHV3\n       Rm93ZFZ3QUZYNXpwUm85cnJWendpUlJCQmlhQm9DUjdo\n       TnFnc3RXN1ZNM1Q5YXVOYnFUbVFXNHZkSGI2MVJoVE1W\n       Z0NwMUJUeHVhS1UzYW5Xb0VSRlhwdVp2ZkUzOWc4dTdI\n       UzlCZUQxUUpOMWZYNlM4dnZza2FQaHhGa3dMdEdyNFpm\n       ZmtVRTU3V1pwTldNNlU2QnFka3RaeG1LenhDODV6TjRG\n       QzlXczVMSHVHZnhhQ3VCTGlVZkE3cUVZVlN6MVF1MXJa\n       RHBENk55ZlVOckhKMUVyWmR1SnVuOTc2bmJGSHJtRG5V\n       NDdSY1NNRkVTYk5LRGkxNDY3dFJmdWJzTXJEemViZENG\n       S1EybTFBWXlzdG8yaTZXbWNudWNqdDN0bndUcWU3Qm84\n       TDFnOGg4VUdBOTQ2REYzV2VHYlBVR3F6bnNVZExxNlhM\n       Q21KekprSm1yTnllWmtzd2R5UFgyVnU2SjlFNEoxMlNi\n       M2g5ZHM3YXRCeWFtZnRpdEVac2Y2aFBKa0xVWEdUaFlw\n       Q25tUkFBclJSZlBZMkg2Y0tEYzdBY25GUHlOSEdrYWI1\n       WkZvNHF2Z0JaeXRiSzFLNW9EM0hmUTZFMnliTGh5QzJi\n       OGk1d282REx0bTl1Zml4U0pOTlRIN1Vpa2s4OENtZXJ0\n       S1I3czEyQ0sxV0xFTTNadTVZQlpOcGhuamo3Y3A4UVRv\n       ZEFlaFJQVjlORzFDTEVBTUpWTjc5RHZZZTZTZmlhZkpv\n       YmN2ZkQ4bnBmUzZqY2VqY3lvdVFiRXBLREc3UUFuS1M0\n       OFA0QXZnQnFEdmZOVWU1NGpNa2s2cjZDb1g0TGNZR0h1\n       a1pERW5lYTlrd2tFb1hrVVlTNGoxQWZiS2g0NEZ6U3VY\n       YlFxWm5qalZwVGh4Q05tbU5uMUU0cUhtc0ZrdkdvRjNG\n       TjU1Q1Brb0dmREN2eVFKZ3Ftc0ZtcGVUSlN5OXd6djRN\n       dmJxcHVBVHhyN2V5eHNHZUNXUWtjRHd1YjMyaW5HcFIz\n       cmVUZnpSSkVDQ0ZaYXJuWGRjQzVQaWRha2IxV3U4TCIs\n       Im5iZiI6MCwicHRjIjoiQVBQRU5EIiwicHJmIjpudWxs\n       LCJzY3AiOiIvIn0.leyE9w2TF28espPq6mOWziQuJny2\n       GHH_wajV6S9q4gF9SLP-i9JaX_XbkHlE1GhpQ36gSs6F\n       v4_AXSuJzDkUhnAA-oPsI5bSHl28XbobzqdmXtQ2liK-\n       Gum7kUtF1CPXlIamV0NIUlCKLlaUgFod5ZQvvA19kMHU\n       ugDGm8O3G98TSm3qLlG-eoFNVXr0NSpvLeui3kQbdBsP\n       GMykaTsUn1fNLI3oKkK6JvUIq4po6gIidTdOJDlS7y_W\n       4bdMXUQcTprtpd2QmTqwTzws9tu4GBdx7q1vz35LiG39\n       ohhRs2NKB4rxbZK2O9kX1G2xLMSETE_YT9GR04XWMnFo\n       eIodsg\"\n\nNested proofYou'll notice that the nested proof is encoded as a bearer token.\nThis is because it needs to include its signature to prove that it's valid, and\na JWT signature is on the content encoded this way.\n\nThis token is thus valid as long as:\n\n * All token signatures are correct\n * The time range, potency, and scope of prf  are greater-or-equal to the\n   enclosing token\n * The outer token's iss  field matches the prf's aud  field (chain \"to\" and\n   \"from\" correctly)\n * The timestamps are valid at the present time\n\nHashing Ô∏è üèéÔ∏è\nThese chains can get large, so you can optionally hash the outermost one before\nsending to a server. This acts as a \"content address\", meaning that if the\nservice hasn't seen it before, it can separately request that token, but if it\nalready has it in cache and doesn't need to get it over the network. Since\nhashes are much smaller than their content, this can save a lot of bandwidth on\nrepeated requests.\n\n\"prf\": \"QmU5WJTTp9vtMN1PBJpTV9xWXbTFBcWx3qjPGuXJXtujyd\"\n\nSame as the example above, but with the proof compressed to a content address\nConclusion\nUCANs are a straightforward way of doing authorization that leverage the public\nkey infrastructure already baked into Fission. This is essentially\nauthorization-at-the-edge with familiar JWTs. Since the token is self-contained,\nit's infinitely scalable. It's also very flexible: the user can grant root\naccess to everything, or grant a tab write access to a single object for one\nminute.\n\nThis article covers everything that you need to use a UCAN. For those interested\nin the space at a deeper level, there's a lot more background and technical\ndesign thinking that we didn't cover here. Keep an eye on our developer forum\n[talk.fission.codes]  for an upcoming article detailing the deeper internals!","html":"<p>Fission is building a system which \"makes the right thing the easy thing.\" It lets you write apps for the browser without having to write or deploy a back end. We're making use of fairly recent browser features and W3C standards to make this all possible. Read on for a technical summary, or <a href=\"https://talk.fission.codes\">join us in the developer forum</a> to get into more detail.</p><p>One of the most common tasks for apps is authorizing users to perform some action, like storing new data to storage, updating records, or fetching a file. </p><p>Traditional app architecture has many users share one database (\"multi-tenant\"), with all user data fully interleaved with each other. Authorization here is primarily focused on keeping users from editing each other's records on this shared infrastructure. The server's rules give fairly coarse-grained control. Due to the inevitable exceptions to these rules, the logic becomes increasingly complex over time.</p><p>Even in a microservice architecture, typically all requests are funneled through a central authorization service. Over time this causes several challenges, including complex logic, cost of maintenance, tricky edge cases, and difficulty managing traffic spikes. In short: it doesn't scale well.</p><p>Even incumbents like<a href=\"https://research.google/pubs/pub41892/\"> Google are moving away from the traditional auth server model</a> to overcome the above challenges. Fission has different constraints from Google and Amazon, but can adapt a lot of these ideas for our purposes. Essentially they're moving from a central auth server setup to a distributed model where more power is delegated to services.</p><p>What if we learn from Google's approach (plus older approaches like <a href=\"https://tools.ietf.org/html/rfc2693\">SDSI/SPKI</a>) but took it to its logic conclusion?</p><h2 id=\"introducing-ucans\">Introducing UCANs</h2><blockquote>User Controlled Authorization Networks (UCANs) are a way of doing authorization where users are fully in control. OAuth is designed for a centralized world, UCAN is the distributed user controlled version.</blockquote><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://s3.fission.codes/2020/05/UCAN_SAM-1.png\" class=\"kg-image\"><figcaption>UCAN Sam</figcaption></figure><!--kg-card-end: image--><p>At a high level, User Controlled Authorization Networks (UCANs) are a way of doing authorization (\"what <em>you can</em> do\") where users are fully in control. There's no all-powerful authorization server, or server of any kind required. Everything that a users is allowed to do is captured directly in a key or token, and can be sent to anyone that knows how to interpret this format.</p><p>Since all Fission accounts are equipped with a global ID and cryptographic keys, we were able to design a system that has very few assumptions and thus works in a huge number of situations.</p><p>This setup has several advantages:</p><ol><li>Low effort:¬†developers don't need to write and maintain complex access logic</li><li>Familiar:¬†uses very common JSON Web Tokens (JWTs)</li><li>Invisible: users don't need to know that anything special is happening</li><li>Flexible: access can be granted as coarse or granular as the end users wants</li><li>Scalable: no auth server bottleneck / scales infinitely</li><li>Secure:¬†military-grade encryption</li><li>Collaborative:¬†users and services and delegate a subset of their access to others</li><li>Self-contained: the token contains all the information needed to verify it</li></ol><p>UCANs are all that we need to sign into multiple machines, delegate access for service providers to do things while we're offline, securely collaborate on documents with a team, and more. We get the flexibility of fine- or coarse-grained control, all controlled by the one who cares about the data the most: the user.</p><p>We've implemented this as the authorization system for Fission, and are also making this available as a building block for developers to solve user authorization and delegation within their own applications.</p><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><p>This system of authorization is broken into two halves: read and write (or \"command and query\", depending on your background). Without getting too in the weeds, here's a high level description of how this all works:</p><h2 id=\"read-query-access\">Read (Query) Access</h2><p>Read access comes in three flavours: public, private, and unlisted. Access follows the <a href=\"https://en.wikipedia.org/wiki/Object-capability_model?oldformat=true\">object-capability model</a>, where anyone with the reference (URL or CID) and cryptograhic key can read the data by virtue of having access to these.</p><h3 id=\"public-\">Public üëÄ</h3><p>Public files are just that: files that can be discovered or accessed by anyone at an easy-to read path.</p><p>Here's a live example: <a href=\"https://boris.fission.name/Photos/boris-with-icecream.jpg\">https://boris.fission.name/Photos/boris-with-icecream.jpg</a></p><h3 id=\"private-\">Private üîê</h3><p>The user encrypts the data, and shares the key with those that should have access. The contents of a private directory is only readable with a key, but once you have access to that directory, all of the data in that directory (including subdirectories and metadata) is accessible.</p><p>The end experience matches the behaviour in other online consumer file storage solutions like Dropbox and Google Drive. A major difference with Fission is that the end user is given complete control over who has access, and access does not depend on Fission's servers being accessible (i.e. you're offline or Fission disappears).</p><h3 id=\"unlisted-\">Unlisted üó∫Ô∏è</h3><p>Sort of a mashup of public and private files! This is useful when you want to (e.g.) embed an image in an email without distributing keys, but also don't want it easily discoverable.</p><p>The unlisted files themselves are left unencrypted, but finding them is practically infeasible without the private index. Think of this index as a secret treasure map for the web ‚Äî the map itself private (only a select few have the map), but anyone with it can find the data at the marked locations.</p><p>Under the hood, the Fission SDK creates a JSON file that lists all of the locations. That JSON file is then encrypted and the key passed to whoever should have access., or the links can be shared directly.</p><p>Here's a simple example of what this looks like:</p><!--kg-card-begin: code--><pre><code class=\"language-javascript\">// The \"treasure map\"\n{\n  \"QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ\": {\n      \"cat.jpg\": \"Qmd286K6pohQcTKYqnS1YhWrCiS4gz7Xi34sdwMe9USZ7u\"\n  }\n}</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code class=\"language-URL\"># URL\nhttps://ipfs.runfission.com/ipfs/QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ/cat.jpg</code></pre><!--kg-card-end: code--><h2 id=\"write-command-access-\">Write (Command) Access üñäÔ∏è</h2><p>There are some actions that a user needs the help of another user or service to perform. For example: sending an email, or updating DNS.</p><p>In a traditional OAuth based system, the \"account\" lives entirely on the server, and the user is granted access with a token<em><em>. </em></em>In Fission's design, the account is a key pair, and a UCAN is equivalent to an OAuth token. OAuth is designed for a centralized client/server world. UCANs are the distributed user controlled equivalent.</p><p>UCANs are simply <a href=\"jwt.io\">JWT</a>s that contain special keys. Much of this will look familiar if you've done web auth in the past decade or so. Here's an example:</p><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-json\">{\n  \"alg\": \"Ed25519\",\n  \"typ\": \"JWT\"\n  \"uav\": \"0.1.0\"\n}\n{\n  \"aud\": \"did:key:zStEZpzSMtTt9k2vszgvCwF4fLQQSyA15W5AQ4z3AR6Bx4eFJ5crJFbuGxKmbma4\",\n  \"iss\": \"did:key:z5C4fuP2DDJChhMBCwAkpYUMuJZdNWWH5NeYjUyY8btYfzDh3aHwT5picHr9Ttjq\",\n  \"nbf\": 1588713622,\n  \"exp\": 1589000000,\n  \"scp\": \"/\"\n  \"ptc\": \"APPEND\",\n  \"prf\": null,\n}</code></pre><figcaption>Example UCAN JSON Web Token</figcaption></figure><!--kg-card-end: code--><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code>Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsInVhdiI6IjAuMS4wIn0.eyJhdWQiOiJkaW\nQ6a2V5OnpTdEVacHpTTXRUdDlrMnZzemd2Q3dGNGZMUVFTeUExNVc1QVE0ejNBUjZCeDRl\nRko1Y3JKRmJ1R3hLbWJtYTQiLCJpc3MiOiJkaWQ6a2V5Ono1QzRmdVAyRERKQ2hoTUJDd0\nFrcFlVTXVKWmROV1dINU5lWWpVeVk4YnRZZnpEaDNhSHdUNXBpY0hyOVR0anEiLCJuYmYi\nOjE1ODg3MTM2MjIsImV4cCI6MTU4OTAwMDAwMCwic2NwIjoiLyIsInB0YyI6IkFQUEVORC\nIsInByZiI6bnVsbH0.Ay8C5ajYWHxtD8y0msla5IJ8VFffTHgVq448Hlr818JtNaTUzNIw\nFiuutEMECGTy69hV9Xu9bxGxTe0TpC7AzV34p0wSFax075mC3w9JYB8yqck_MEBg_dZ1xl\nJCfDve60AHseKPtbr2emp6hZVfTpQGZzusstimAxyYPrQUWv9wqTFmin0Ls-loAWamleUZ\noE1Tarlp_0h9SeV614RfRTC0e3x_VP9Ra_84JhJHZ7kiLf44TnyPl_9AbzuMdDwCvu-zX\njd_jMlDyYcuwamJ15XqrgykLOm0WTREgr_sNLVciXBXd6EQ-Zh2L7hd38noJm1P_MIr9_\nEDRWAhoRLXPQ</code></pre><figcaption>The same, as a bearer token (for an HTTP <code>Authorization</code> header)</figcaption></figure><!--kg-card-end: code--><p>Let's break that down:</p><h2 id=\"header-\">Header üìã</h2><p>This is a standard JWT header, plus a <code>uav</code> field.</p><ul><li><code>alg</code> ‚Äî type of signature</li><li><code>typ</code> ‚Äî¬†state that this is a JWT</li><li><code>uav</code> ‚Äî \"UCAN version\" (so we can track the format of when it was issued)</li></ul><h2 id=\"body-\">Body üí™</h2><ul><li><code>aud</code> \"Audience\" ‚Äî¬†the ID of who it's intended for (the \"to\" field)</li><li><code>iss</code> \"Issuer\" ‚Äî¬†ID of who sent it (the \"from\" field)</li><li><code>nbf</code> \"Not Before\" ‚Äî¬†Unix timestamp of when it becomes valid (typically when it was created, but not always)</li><li><code>exp</code> \"Expiry\" ‚Äî¬†Unix timestamp of when it stops being valid</li><li><code>scp</code> \"Scope\" ‚Äî¬†The scope of things it's able to change (e.g. a file system path)</li><li><code>ptc</code> \"Potency\" ‚Äî what rights comes with the token (in this case it's append only)</li><li><code>prf</code> \"Proof\" ‚Äî an optional nested token with equal or greater privileges</li></ul><p>These are then all signed with the user's private key. This key must match the public key in the <code>iss</code> field (user IDs are public keys), directly authenticating the token. As the token is a complete description of access, this token is self-validating with no need to look at other data or services.</p><h3 id=\"delegation-\">Delegation ü§ù</h3><p>What if you want to grant another user or service the ability to perform some action on your behalf? As long as they have a valid UCAN, they can wrap it in another with equal or lesser rights and include the original in the <code>prf</code> field.</p><p>Since every UCAN layer is self-signed, we can trace back to the root (no <code>prf</code> field), and know who the delegate is acting as. This chain of tokens is itself is the proof that you're perform some action.</p><p>For example, here's a chain:</p><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-plaintext\">\"prf\":\"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\n       eyJhdWQiOiJkaWQ6a2V5OnpTdEVacHpTTXRUdDlrMnZz\n       emd2Q3dGNGZMUVFTeUExNVc1QVE0ejNBUjZCeDRlRko1\n       Y3JKRmJ1R3hLbWJtYTQiLCJleHAiOjE1ODgyNjU0MjAs\n       ImlzcyI6ImRpZDprZXk6ejFMQm53RWt0d1lMcnBQaHV3\n       Rm93ZFZ3QUZYNXpwUm85cnJWendpUlJCQmlhQm9DUjdo\n       TnFnc3RXN1ZNM1Q5YXVOYnFUbVFXNHZkSGI2MVJoVE1W\n       Z0NwMUJUeHVhS1UzYW5Xb0VSRlhwdVp2ZkUzOWc4dTdI\n       UzlCZUQxUUpOMWZYNlM4dnZza2FQaHhGa3dMdEdyNFpm\n       ZmtVRTU3V1pwTldNNlU2QnFka3RaeG1LenhDODV6TjRG\n       QzlXczVMSHVHZnhhQ3VCTGlVZkE3cUVZVlN6MVF1MXJa\n       RHBENk55ZlVOckhKMUVyWmR1SnVuOTc2bmJGSHJtRG5V\n       NDdSY1NNRkVTYk5LRGkxNDY3dFJmdWJzTXJEemViZENG\n       S1EybTFBWXlzdG8yaTZXbWNudWNqdDN0bndUcWU3Qm84\n       TDFnOGg4VUdBOTQ2REYzV2VHYlBVR3F6bnNVZExxNlhM\n       Q21KekprSm1yTnllWmtzd2R5UFgyVnU2SjlFNEoxMlNi\n       M2g5ZHM3YXRCeWFtZnRpdEVac2Y2aFBKa0xVWEdUaFlw\n       Q25tUkFBclJSZlBZMkg2Y0tEYzdBY25GUHlOSEdrYWI1\n       WkZvNHF2Z0JaeXRiSzFLNW9EM0hmUTZFMnliTGh5QzJi\n       OGk1d282REx0bTl1Zml4U0pOTlRIN1Vpa2s4OENtZXJ0\n       S1I3czEyQ0sxV0xFTTNadTVZQlpOcGhuamo3Y3A4UVRv\n       ZEFlaFJQVjlORzFDTEVBTUpWTjc5RHZZZTZTZmlhZkpv\n       YmN2ZkQ4bnBmUzZqY2VqY3lvdVFiRXBLREc3UUFuS1M0\n       OFA0QXZnQnFEdmZOVWU1NGpNa2s2cjZDb1g0TGNZR0h1\n       a1pERW5lYTlrd2tFb1hrVVlTNGoxQWZiS2g0NEZ6U3VY\n       YlFxWm5qalZwVGh4Q05tbU5uMUU0cUhtc0ZrdkdvRjNG\n       TjU1Q1Brb0dmREN2eVFKZ3Ftc0ZtcGVUSlN5OXd6djRN\n       dmJxcHVBVHhyN2V5eHNHZUNXUWtjRHd1YjMyaW5HcFIz\n       cmVUZnpSSkVDQ0ZaYXJuWGRjQzVQaWRha2IxV3U4TCIs\n       Im5iZiI6MCwicHRjIjoiQVBQRU5EIiwicHJmIjpudWxs\n       LCJzY3AiOiIvIn0.leyE9w2TF28espPq6mOWziQuJny2\n       GHH_wajV6S9q4gF9SLP-i9JaX_XbkHlE1GhpQ36gSs6F\n       v4_AXSuJzDkUhnAA-oPsI5bSHl28XbobzqdmXtQ2liK-\n       Gum7kUtF1CPXlIamV0NIUlCKLlaUgFod5ZQvvA19kMHU\n       ugDGm8O3G98TSm3qLlG-eoFNVXr0NSpvLeui3kQbdBsP\n       GMykaTsUn1fNLI3oKkK6JvUIq4po6gIidTdOJDlS7y_W\n       4bdMXUQcTprtpd2QmTqwTzws9tu4GBdx7q1vz35LiG39\n       ohhRs2NKB4rxbZK2O9kX1G2xLMSETE_YT9GR04XWMnFo\n       eIodsg\"</code></pre><figcaption>Nested proof</figcaption></figure><!--kg-card-end: code--><p>You'll notice that the nested proof is encoded as a bearer token. This is because it needs to include its signature to prove that it's valid, and a JWT signature is on the content encoded this way.</p><p>This token is thus valid as long as:</p><ul><li>All token signatures are correct</li><li>The time range, potency, and scope of <code>prf</code> are greater-or-equal to the enclosing token</li><li>The outer token's <code>iss</code> field matches the <code>prf</code>'s <code>aud</code> field (chain \"to\" and \"from\" correctly)</li><li>The timestamps are valid at the present time</li></ul><h3 id=\"hashing-\">Hashing Ô∏è üèéÔ∏è</h3><p>These chains can get large, so you can optionally hash the outermost one before sending to a server. This acts as a \"content address\", meaning that if the service hasn't seen it before, it can separately request that token, but if it already has it in cache and doesn't need to get it over the network. Since hashes are much smaller than their content, this can save a lot of bandwidth on repeated requests.</p><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code>\"prf\": \"QmU5WJTTp9vtMN1PBJpTV9xWXbTFBcWx3qjPGuXJXtujyd\"</code></pre><figcaption>Same as the example above, but with the proof compressed to a content address</figcaption></figure><!--kg-card-end: code--><h1 id=\"conclusion\">Conclusion</h1><p>UCANs are a straightforward way of doing authorization that leverage the public key infrastructure already baked into Fission. This is essentially authorization-at-the-edge with familiar JWTs. Since the token is self-contained, it's infinitely scalable. It's also very flexible: the user can grant root access to everything, or grant a tab write access to a single object for one minute.</p><p>This article covers everything that you need to use a UCAN. For those interested in the space at a deeper level, there's a lot more background and technical design thinking that we didn't cover here. Keep an eye on <a href=\"talk.fission.codes\">our developer forum</a> for an upcoming article detailing the deeper internals!</p>","url":"https://blog.fission.codes/auth-without-backend/","canonical_url":null,"uuid":"9bd5ed02-502d-4e31-828c-6ad1fa4613b9","page":false,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eb19b7a82ce80001ee86716","reading_time":null}},{"node":{"id":"Ghost__Post__5e274d05fbc2c9001eeb9759","title":"Everything you wanted to know about Elliptic Curve Cryptography","slug":"everything-you-wanted-to-know-about-elliptic-curve-cryptography","featured":true,"feature_image":"https://s3.fission.codes/2020/03/math.jpg","excerpt":"So you've heard of Elliptic Curve Cryptography. Maybe you know it's supposed to\nbe better than RSA. Maybe you know that all these cool new decentralized\nprotocols use it. Maybe you've seen the landslide of acronyms that go along with\nit: ECC, ECDSA, ECDH, EdDSA, Ed25519, etc. Maybe you've seen some cool looking\ngraphs but don't know how those translate to working cryptography. The articles\nyou find online either don't answer your questions, or launch in to a 30 minute\ndescription of birational e","custom_excerpt":null,"created_at_pretty":"21 January, 2020","published_at_pretty":"19 March, 2020","updated_at_pretty":"19 March, 2020","created_at":"2020-01-21T11:12:05.000-08:00","published_at":"2020-03-18T18:50:41.000-07:00","updated_at":"2020-03-19T09:16:18.000-07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Daniel Holmgren","slug":"daniel","bio":null,"profile_image":"https://s3.fission.codes/2019/09/75f5c64c98dbaf2b49b86c299104ab06.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Daniel Holmgren","slug":"daniel","bio":null,"profile_image":"https://s3.fission.codes/2019/09/75f5c64c98dbaf2b49b86c299104ab06.png","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"cryptography","slug":"cryptography","description":null,"feature_image":null,"meta_description":null,"meta_title":null},"tags":[{"name":"cryptography","slug":"cryptography","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"elliptic","slug":"elliptic","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"ecc","slug":"ecc","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"keys","slug":"keys","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"DID","slug":"did","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"encryption","slug":"encryption","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"Technology Highlight","slug":"technology-highlight","description":null,"feature_image":null,"meta_description":null,"meta_title":null}],"plaintext":"So you've heard of Elliptic Curve Cryptography. Maybe you know it's supposed to\nbe better than RSA. Maybe you know that all these cool new decentralized\nprotocols use it. Maybe you've seen the landslide of acronyms that go along with\nit: ECC, ECDSA, ECDH, EdDSA, Ed25519, etc. Maybe you've seen some cool looking\ngraphs but don't know how those translate to working cryptography. The articles\nyou find online either don't answer your questions, or launch in to a 30 minute\ndescription of birational equivalence.\n\nWe feel your pain. We wanted to create a resource that answers all those\nquestions you have, gives you a cheat sheet for those pesky acronyms, and takes\nyou from crypto-kindergartener to elliptic-expert in less than 10 minutes.\n\nEnough with the talk! I just need to figure out what all these funky acronyms\nmean!\n  \nRSA:  Rivest‚ÄìShamir‚ÄìAdleman (the three inventors of RSA)\nOld school cryptography that uses prime-factorization\n\nECC:  Elliptic Curve Cryptography\nNew-fangled cryptography that uses elliptic curves. More secure & smaller keys\nthan RSA.\n\nECDH:  Elliptic Curve Diffie Hellman\nKey-sharing algorithm used for asymmetric encryption\n\nECDSA:  Elliptic Curve Digital Signing Algorithm\nDigital signing algorithm using elliptic curves (makes sense right?)\n\nEdwards Curve:  \nA special type of elliptic curve (most are Montgomery Curves). Faster for\ncertain operations.\n\nEdDSA:  Edwards Digital Signing Algorithm\nDigital signing algorithm using an Edwards curve. Runs in constant time.\n\nEd25519:  Edwards Curve 25519\nThe most commonly used Edwards Curve\n\nCurve25519:\nThe non-edwards companion to Ed25519\n\nsecp256k1:\nThe curve used by Bitcoin & Ethereum\n\nNIST Curves:\nCurves created and standardized by the National Institute of Standards and\nTechnology \n\nWhat is asymmetric cryptography?\n\nAsymmetric cryptography  (or \"public key cryptography\") is a cryptographic\nsystem that uses keypairs (a private key and a public key). The public key is\nshared widely, while the private key must be kept \ncompletely secret. \n\nThere are two main use cases for public key cryptography: asymmetric encryption\nand digital signatures.\n\nAsymmetric encryption  is a method by which Alice can send a message to Bob\nwithout leaking any information about her private key to Bob and nothing about\nthe key or the message to the outside world. \n\nDigital signatures  are a means of verifying that a message came from the holder\nof a certain private key and that the information has not been tampered with in\nflight.\n\nHow on earth does that work?\n\nAll public key cryptography relies on the existence of one-way functions:\nmathematical functions that are very easy to calculate in one direction but\nnearly impossible to \"undo\", or calculate in the other direction.\n\nRSA has been the predominant cryptosystem since its introduction in 1977. It\nrelies on prime factorization  of very large numbers.\n\nPrime factorization is the process of breaking a number down into the product of\nprime numbers. This is easy with small numbers: for instance, the prime factors\nof 70 are 2 * 5 * 7. Now do that with a 2048-bit integer, and it ends up being\npretty complicated.\n\nSweet good thing someone figured that out. Now we can all kick back and relax\nknowing all of our information is secure!\n\nWell, computers are a lot faster nowadays than in 1977. Unfortunately that means\nthat they're also getting faster at factoring large prime numbers. While a 256\nbit key might've cut it at one point, now that key can be broken in ‚åöüëÄ, 103\nseconds. \n\nComputers and prime numbers are now in an arms race, with the current key size\nrecommendation being 2048 bits. As keys get larger, operations obviously become\nslower. Meanwhile, the threat of quantum computing looms on the horizon. The now\ninfamous Shor's algorithm [https://en.wikipedia.org/wiki/Shor%27s_algorithm] \nthreatens to solve prime factorization in polynomial time. Which would render\nRSA as good as done.\n\nIs there no hope for privacy?!\n\nThere's a new one-way function on the block: Elliptic Curve Cryptography. Now\nwith 100% less prime factorization! \n\nWhat's an elliptic curve?\n\nElliptic curves are cool looking curves that look like this: \n\nAnd are graphed with equations that looks like this: \n\ny^2 = x^3 + ax + b\n\nExcept decimals are a bit unruly so we only take the integers, and then take a\nmodulus of the function (basically wrap the graph around the edges like an old\ngame of snake), so the graph actually ends up looking something like this (note\nthere's still a horizontal line of symmetry):\n\nAlright, but what do these have to do with cryptography?\nThe basic procedure of ECC is this:\n\n * Choose a curve and a point P  on the curve (everyone uses the same point)\n * Choose an arbitrary very large number N  (this is your private key).\n * Using point addition, add P  to itself N  times\n * The x-coordinate of N*P  is your public-key\n\nCan you ground this in reality a bit?\n\nSure! Let's draw an analogy to adjusting a clock. Here are the same steps listed\nout but with a clock instead of an elliptic curve:\n\n * Grab a clock sitting at exactly midnight and choose an arbitrary number of\n   seconds P\n * Choose a very large number N\n * Move the clock forward P  seconds N  times (pretend you have really fast\n   hands üòú)\n * Give the clock to a friend and tell them how big each step was (P) then see\n   if they can figure out how many times you moved it (N) to arrive at the\n   current location\n\nAnd how well does this whole thing work?\n\nIt turns out this is a much more robust one-way function than prime\nfactorization. In fact, we can achieve the same security as a 3072-bit RSA key\nwith a 256-bit ECC key. Not bad!\n\nWhat if someone guesses the same number N  that I chose?\n\nThere's a mind-blowingly large range of numbers to choose from. Each key is 256\nbits so you have 2^256 = 10^77  options. To give you a scale of how big this is,\nthere are: \n\n * ~10^18  grains of sand on earth\n * ~10^22  stars in the observable universe\n * ~10^78  atoms in the observable universe\n\nSo guessing someone's private key would be approximately equivalent to guessing\na random atom in the universe.\n\nDoesn't it take a long time to calculate my public key?\n\nNope, point addition is associative. Meaning:\nP + P + P + P = (P + P) + (P + P) = 2P + 2P\n\nSo when calculating a N*P  for a very large N, you only need to calculate P + 2P\n+ 4P + 8P...\n\nAt most, you must calculate 256 terms. Trivial for a computer. But to guess the\npublic key for a given private key, you would need to check every number in\nbetween (that big number we talked about earlier).\n\nHow do these keys translate into cryptographic functions?\n\nECDH  is a key sharing algorithm, most commonly used to send encrypted messages.\nECDH works by multiplying your private key by another's public key to get a\nshared secret, then using that shared secret to perform symmetric encryption.\n\nTo illustrate why this works:\n\n * Alice and Bob agree on a curve with starting point P\n * Alice has a private key a  and public key A = a * P\n * Bob has a private key b  and public key B = b * P\n * a * B = a * b * P = b * A\n * So a * b * P  ends up being the shared secret\n\nECDSA is a signature algorithm, used to prove authenticity of some information.\nThe algorithm is a bit trickier than ECDH. \nWarning: lots of equations, feel free to skip to the takeways below.\n\n * Alice and bob agree on a curve with starting point P\n * Alice has a private key a  and public key A = a * P\n * Alice chooses a random k  and point K = k * P\n * Alice takes r  which is just the x-value of K\n * Alice hashes her message to produce hash H\n * Alice calculates a value s = inv(k)*(H+ra)\n * Alice sends her message to Bob along with the signature (r, s)\n * Bob calculates H  from the message\n * Bob ensures that r = H*inv(s)*P + r*inv(s)*A\n * If it does, the signature is valid!\n\nIf you skipped those equations or they don't quite click, the key takeaways \nare:\n\n * Alice sends a random value r  and a calculated value s  that could only be\n   calculated with a combination of the private key, the message hash, and the\n   random value, but gives away no information about her private key.\n * Bob can verify r  and s  by using just the message hash and Alice's public\n   key\n * You need  a good source of randomness to use ECDSA. If you're randomness\n   function is broken, repeated signatures can disclose your private key\n\nReal quick, you mentioned symmetric encryption. How does that work?\nSymmetric encryption uses just one key to encrypt and decrypt a message.\nEncrypted messages just look like random jumbles of letters and numbers that\ngive no information about the underlying message unless you have the key to\n\"unjumble\" it. Most algorithms use a block cipher. This involves choosing a\nblock size (say 64 bits), and encrypting the message in blocks of that size.\n\nWe mentioned symmetric encryption when talking about ECDH. When people say\n\"asymmetrically encrypted\", they actually mean \"symmetrically encrypted with a\nsecret that is shared asymmetrically\".\n\nA few examples of algorithms are AES\n[https://en.wikipedia.org/wiki/Advanced_Encryption_Standard], Salsa20\n[https://en.wikipedia.org/wiki/Salsa20], or Triplesec\n[https://keybase.io/triplesec]  (which is actually just a combo of the first two\nfor extra security).\n\nOkay, I generally understand how this works, but how do people decide on a curve\nand a point P?\n\nA bunch of different ways, sometimes they're chosen for a specific reason,\nsometimes they're algorithmically determined. Different curves have different\nproperties. Checkout Safe Curves [https://safecurves.cr.yp.to/]  for an analysis\nof different curves.\n\nCan \"faulty\" curves give backdoors?\n\nYes! Faulty curves can give shortcuts to determining a private key from a given\npublic key. \n\nMany suspect that NIST curves have NSA backdoors in them.  This is because a\npublished NIST randomization algorithm (that the NSA tightly collaborated on)\nwas found to have a backdoor.\n[https://www.ams.org/notices/201402/rnoti-p190.pdf]  We encourage you not to use\nany curves published by the NIST!\n\nWhat's this \"Edwards Curve\" I keep hearing about?\n\nMost Elliptic curves are Montgomery Curves\n[https://en.wikipedia.org/wiki/Montgomery_curve]. Edwards Curves were described\nby mathematician Harold Edwards and popularized by cryptographer Daniel\nBernstein. They have a different structure that allows for a faster signature\nalgorithm. This signature algorithm, when performed on an Edwards curve, is\ncalled EdDSA. This algorithm runs in constant time, meaning it's faster and\nleaks less information\n\nCan Edwards Curves do key sharing?\n\nEdwards curves are specifically used for signatures. There is not a related\nDiffie-Hellman key sharing algorithm.\n\nSo if I want to use both ECDH & EdDSA, I need two key pairs?\n\nNot exactly. Let's take the most common Edwards curve Ed25519. This curve is\nrelated to Montgomery curve Curve25519. In fact Ed25519 is a twist\n[https://en.wikipedia.org/wiki/Twists_of_curves]  of Curve25519. A \"twist\"\nbasically means that the curves are mappable to one another. What this means is\nthat you can use the same private key to generate a public key on both curves\nand then transform those public keys between one another without any knowledge\nof the private key. Specifically, with these equations.\n\n(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)\n(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))\n\n\nwhere (u, v)  is the Curve25519 point and (x, y)  is the Ed25519 point\n\nYou can read a more in-depth post about that Here\n[https://blog.filippo.io/using-ed25519-keys-for-encryption/].\n\nWhat cryptography algorithms do protocols like Bitcoin, Ethereum, and IPFS use?\n\nBitcoin uses secp256k1  for completely arbitrary reasons\n[https://bitcointalk.org/index.php?topic=2699.msg37328#msg37328]\nEtherem uses secp256k1  for interop with Bitcoin\n[https://forum.ethereum.org/discussion/comment/53/#Comment_53]\nIPFS uses Ed25519  and RSA.\n\nOkay so what do you recommend?\nWe're using Ed25519 & Curve25519. We chose these because:\n\n * They are well-recognized as safe curves [https://safecurves.cr.yp.to/]\n * They are one of the more commonly used curves, so we have easier interop\n * They allow us to use EdDSA for signatures\n * We're fairly certain that they don't have any backdoors in them\n\nThis is sweet! Why doesn't everyone have a private key??\n\nWe ask ourselves the same question everyday. The main reason is: it's a pain.\nKeys look scary (6A576D5A7134743777217A25432A462D4A614...). And if you lose a\nkey, you're forever screwed. There's no \"recovery by email\" available. \n\nWhat are people doing about this?\n\nWe need to fix the UX of public keys. Remove the scary hexadecimal strings and\nprovide more painless recovery.\n\nA few options are\n\n * Replication: Share the same key across multiple devices. If you drop your\n   phone in a lake, you can recover your key with your laptop\n * Shamir Secret Sharing: This involves splitting a key up into separate\n   \"shares\". Each share reveals nothing about the key, but by combining the\n   shares back together, you can recover the private key. This leads to\n   interesting solutions like social recovery\n   [https://www.coindesk.com/pay-your-friends-to-protect-your-keys-one-startups-new-take-on-crypto-custody] \n    or zero-knowledge key recovery\n   [https://medium.com/@amanladia1/zerowallet-a-zkp-based-wallet-authentication-mechanism-9871dcca0a01] \n    which we implemented as a Proof of Concept\n   [https://github.com/fission-suite/zerowallet-poc].\n * Secure Hardware Enclaves: Many phones and computers that are coming out these\n   days have Secure Hardware Enclaves. These use both hardware and software to\n   provide very  strong security gurantees\n * Hardware Secure Modules (HSMs): These are similar to Secure Hardware\n   Enclaves, but larger and hold more information. Physical modules exist, and\n   you can also rent space from cloud providers such as AWS. Less\n   security-minded users might be interested in backing up their keys with a\n   \"trusted custodian\" (this still ends up being quite a bit safer than the\n   internet's current security model).\n\nHow are you using private keys?\n\nHere at Fission, we wanted to get private keys into the hands of our users as\nquickly as possible. We just rolled out our new authentication scheme which uses\nprivate keys to power our command line tool: Fission Live\n[https://github.com/fission-suite/cli]. Give it a go and let us know what you\nthink! We have other big projects coming down the pipeline soon that will use\nthis public key infrastructure to power some really neat features: a global\nencrypted filesystem, cryptographically verifiable claims, and more!","html":"<p>So you've heard of Elliptic Curve Cryptography. Maybe you know it's supposed to be better than RSA. Maybe you know that all these cool new decentralized protocols use it. Maybe you've seen the landslide of acronyms that go along with it: ECC, ECDSA, ECDH, EdDSA, Ed25519, etc. Maybe you've seen some cool looking graphs but don't know how those translate to working cryptography. The articles you find online either don't answer your questions, or launch in to a 30 minute description of <em>birational equivalence</em>.<br><br>We feel your pain. We wanted to create a resource that answers all those questions you have, gives you a cheat sheet for those pesky acronyms, and takes you from crypto-kindergartener to elliptic-expert in less than 10 minutes.</p><h3 id=\"enough-with-the-talk-i-just-need-to-figure-out-what-all-these-funky-acronyms-mean-\">Enough with the talk! I just need to figure out what all these funky acronyms mean!</h3><p> <br><strong>RSA:</strong> Rivest‚ÄìShamir‚ÄìAdleman (the three inventors of RSA)<br>Old school cryptography that uses prime-factorization<br><br><strong>ECC:</strong> Elliptic Curve Cryptography<br>New-fangled cryptography that uses elliptic curves. More secure &amp; smaller keys than RSA.<br><br><strong>ECDH:</strong> Elliptic Curve Diffie Hellman<br>Key-sharing algorithm used for asymmetric encryption<br><br><strong>ECDSA:</strong> Elliptic Curve Digital Signing Algorithm<br>Digital signing algorithm using elliptic curves (makes sense right?)<br><br><strong>Edwards Curve:</strong> <br>A special type of elliptic curve (most are Montgomery Curves). Faster for certain operations.<br><br><strong>EdDSA:</strong> Edwards Digital Signing Algorithm<br>Digital signing algorithm using an Edwards curve. Runs in constant time.<br><br><strong>Ed25519:</strong> Edwards Curve 25519<br>The most commonly used Edwards Curve<br><br><strong>Curve25519:</strong><br>The non-edwards companion to Ed25519<br><br><strong>secp256k1:</strong><br>The curve used by Bitcoin &amp; Ethereum<br><br><strong>NIST Curves:</strong><br>Curves created and standardized by the National Institute of Standards and Technology </p><h3 id=\"what-is-asymmetric-cryptography\">What is asymmetric cryptography?<br></h3><p><strong>Asymmetric cryptography</strong> (or \"public key cryptography\") is a cryptographic system that uses keypairs (a private key and a public key). The public key is shared widely, while the private key must be kept <br>completely secret. <br><br>There are two main use cases for public key cryptography: asymmetric encryption and digital signatures.<br><br><strong>Asymmetric encryption</strong> is a method by which Alice can send a message to Bob without leaking any information about her private key to Bob and nothing about the key or the message to the outside world. <br><br><strong>Digital signatures</strong> are a means of verifying that a message came from the holder of a certain private key and that the information has not been tampered with in flight.</p><h3 id=\"how-on-earth-does-that-work\">How on earth does that work?<br></h3><p>All public key cryptography relies on the existence of <strong>one-way functions</strong>: mathematical functions that are very easy to calculate in one direction but nearly impossible to \"undo\", or calculate in the other direction.<br><br>RSA has been the predominant cryptosystem since its introduction in 1977. It relies on <strong>prime factorization</strong> of very large numbers.<br><br>Prime factorization is the process of breaking a number down into the product of prime numbers. This is easy with small numbers: for instance, the prime factors of 70 are 2 * 5 * 7. Now do that with a 2048-bit integer, and it ends up being pretty complicated.</p><h3 id=\"sweet-good-thing-someone-figured-that-out-now-we-can-all-kick-back-and-relax-knowing-all-of-our-information-is-secure-\">Sweet good thing someone figured that out. Now we can all kick back and relax knowing all of our information is secure!<br></h3><p>Well, computers are a lot faster nowadays than in 1977. Unfortunately that means that they're also getting faster at factoring large prime numbers. While a 256 bit key might've cut it at one point, now that key can be broken in ‚åöüëÄ, 103 seconds. <br><br>Computers and prime numbers are now in an arms race, with the current key size recommendation being 2048 bits. As keys get larger, operations obviously become slower. Meanwhile, the threat of quantum computing looms on the horizon. The now infamous <a href=\"https://en.wikipedia.org/wiki/Shor%27s_algorithm\">Shor's algorithm</a> threatens to solve prime factorization in polynomial time. Which would render RSA as good as done.</p><h3 id=\"is-there-no-hope-for-privacy-\">Is there no hope for privacy?!<br></h3><p>There's a new one-way function on the block: <strong>Elliptic Curve Cryptography</strong>. Now with 100% less prime factorization! </p><h3 id=\"what-s-an-elliptic-curve\">What's an elliptic curve?<br></h3><p>Elliptic curves are cool looking curves that look like this: </p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card\"><img src=\"https://s3.fission.codes/2020/01/ecc.png\" class=\"kg-image\"></figure><!--kg-card-end: image--><p>And are graphed with equations that looks like this: </p><!--kg-card-begin: markdown--><p><code>y^2 = x^3 + ax + b</code></p>\n<!--kg-card-end: markdown--><p>Except decimals are a bit unruly so we only take the integers, and then take a modulus of the function (basically wrap the graph around the edges like an old game of snake), so the graph actually ends up looking something like this (note there's still a horizontal line of symmetry):</p><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card\"><img src=\"https://s3.fission.codes/2020/01/sageplot_06.png\" class=\"kg-image\"></figure><!--kg-card-end: image--><h3 id=\"alright-but-what-do-these-have-to-do-with-cryptography\">Alright, but what do these have to do with cryptography?</h3><!--kg-card-begin: markdown--><p>The basic procedure of ECC is this:</p>\n<ul>\n<li>Choose a curve and a point <code>P</code> on the curve (everyone uses the same point)</li>\n<li>Choose an arbitrary very large number <code>N</code> (this is your private key).</li>\n<li>Using point addition, add <code>P</code> to itself <code>N</code> times</li>\n<li>The x-coordinate of <code>N*P</code> is your public-key</li>\n</ul>\n<!--kg-card-end: markdown--><h3 id=\"can-you-ground-this-in-reality-a-bit\">Can you ground this in reality a bit?<br></h3><p>Sure! Let's draw an analogy to adjusting a clock. Here are the same steps listed out but with a clock instead of an elliptic curve:</p><!--kg-card-begin: markdown--><ul>\n<li>Grab a clock sitting at exactly midnight and choose an arbitrary number of seconds <code>P</code></li>\n<li>Choose a very large number <code>N</code></li>\n<li>Move the clock forward <code>P</code> seconds <code>N</code> times (pretend you have really fast hands üòú)</li>\n<li>Give the clock to a friend and tell them how big each step was (<code>P</code>) then see if they can figure out how many times you moved it (<code>N</code>) to arrive at the current location</li>\n</ul>\n<!--kg-card-end: markdown--><h3 id=\"and-how-well-does-this-whole-thing-work\">And how well does this whole thing work?<br></h3><p>It turns out this is a much more robust one-way function than prime factorization. In fact, we can achieve the same security as a 3072-bit RSA key with a 256-bit ECC key. Not bad!</p><h3 id=\"what-if-someone-guesses-the-same-number-n-that-i-chose\">What if someone guesses the same number <em>N</em> that I chose?<br></h3><p>There's a mind-blowingly large range of numbers to choose from. Each key is 256 bits so you have <code>2^256 = 10^77</code> options. To give you a scale of how big this is, there are: </p><!--kg-card-begin: markdown--><ul>\n<li><code>~10^18</code> grains of sand on earth</li>\n<li><code>~10^22</code> stars in the observable universe</li>\n<li><code>~10^78</code> atoms in the observable universe</li>\n</ul>\n<!--kg-card-end: markdown--><p>So guessing someone's private key would be approximately equivalent to guessing a random atom in the <em>universe.</em></p><h3 id=\"doesn-t-it-take-a-long-time-to-calculate-my-public-key\">Doesn't it take a long time to calculate my public key?<br></h3><p>Nope, point addition is associative. Meaning:<br><code>P + P + P + P = (P + P) + (P + P) = 2P + 2P</code><br><br>So when calculating a <code>N*P</code> for a very large <code>N</code>, you only need to calculate <code>P + 2P + 4P + 8P...</code> ¬†<br><br>At most, you must calculate 256 terms. Trivial for a computer. But to guess the public key for a given private key, you would need to check every number in between (that big number we talked about earlier).</p><h3 id=\"how-do-these-keys-translate-into-cryptographic-functions\">How do these keys translate into cryptographic functions?<br></h3><p><strong>ECDH</strong> is a key sharing algorithm, most commonly used to send encrypted messages. ECDH works by multiplying your private key by another's public key to get a shared secret, then using that shared secret to perform symmetric encryption.</p><!--kg-card-begin: markdown--><p>To illustrate why this works:</p>\n<ul>\n<li>Alice and Bob agree on a curve with starting point <code>P</code></li>\n<li>Alice has a private key <code>a</code> and public key <code>A = a * P</code></li>\n<li>Bob has a private key <code>b</code> and public key <code>B = b * P</code></li>\n<li><code>a * B = a * b * P = b * A</code></li>\n<li>So <code>a * b * P</code> ends up being the shared secret</li>\n</ul>\n<!--kg-card-end: markdown--><p><strong>ECDSA </strong>is a signature algorithm, used to prove authenticity of some information. The algorithm is a bit trickier than ECDH. <br><em>Warning: lots of equations, feel free to skip to the takeways below.</em></p><!--kg-card-begin: markdown--><ul>\n<li>Alice and bob agree on a curve with starting point <code>P</code></li>\n<li>Alice has a private key <code>a</code> and public key <code>A = a * P</code></li>\n<li>Alice chooses a random <code>k</code> and point <code>K = k * P</code></li>\n<li>Alice takes <code>r</code> which is just the x-value of <code>K</code></li>\n<li>Alice hashes her message to produce hash <code>H</code></li>\n<li>Alice calculates a value <code>s = inv(k)*(H+ra)</code></li>\n<li>Alice sends her message to Bob along with the signature <code>(r, s)</code></li>\n<li>Bob calculates <code>H</code> from the message</li>\n<li>Bob ensures that <code>r = H*inv(s)*P + r*inv(s)*A</code></li>\n<li>If it does, the signature is valid!</li>\n</ul>\n<p>If you skipped those equations or they don't quite click, the key <strong>takeaways</strong> are:</p>\n<ul>\n<li>Alice sends a random value <code>r</code> and a calculated value <code>s</code> that could only be calculated with a combination of the private key, the message hash, and the random value, but gives away no information about her private key.</li>\n<li>Bob can verify <code>r</code> and <code>s</code> by using just the message hash and Alice's public key</li>\n<li>You <em>need</em> a good source of randomness to use ECDSA. If you're randomness function is broken, repeated signatures can disclose your private key</li>\n</ul>\n<!--kg-card-end: markdown--><h3 id=\"real-quick-you-mentioned-symmetric-encryption-how-does-that-work\">Real quick, you mentioned symmetric encryption. How does that work?</h3><p>Symmetric encryption uses just one key to encrypt and decrypt a message. Encrypted messages just look like random jumbles of letters and numbers that give no information about the underlying message unless you have the key to \"unjumble\" it. Most algorithms use a <strong>block cipher. </strong>This involves choosing a block size (say 64 bits), and encrypting the message in blocks of that size.</p><p>We mentioned symmetric encryption when talking about ECDH. When people say \"asymmetrically encrypted\", they actually mean \"symmetrically encrypted with a secret that is shared asymmetrically\".</p><p>A few examples of algorithms are <a href=\"https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\">AES</a>, <a href=\"https://en.wikipedia.org/wiki/Salsa20\">Salsa20</a>, or <a href=\"https://keybase.io/triplesec\">Triplesec</a> (which is actually just a combo of the first two for <em>extra security</em>).</p><h3 id=\"okay-i-generally-understand-how-this-works-but-how-do-people-decide-on-a-curve-and-a-point-p\">Okay, I generally understand how this works, but how do people decide on a curve and a point P?<br></h3><p>A bunch of different ways, sometimes they're chosen for a specific reason, sometimes they're algorithmically determined. Different curves have different properties. Checkout <a href=\"https://safecurves.cr.yp.to/\">Safe Curves</a> for an analysis of different curves.</p><h3 id=\"can-faulty-curves-give-backdoors\">Can \"faulty\" curves give backdoors?<br></h3><p>Yes! Faulty curves can give shortcuts to determining a private key from a given public key. <br><br><em>Many suspect that NIST curves have NSA backdoors in them.</em> <a href=\"https://www.ams.org/notices/201402/rnoti-p190.pdf\">This is because a published NIST randomization algorithm (that the NSA tightly collaborated on) was found to have a backdoor.</a> We encourage you not to use any curves published by the NIST!</p><h3 id=\"what-s-this-edwards-curve-i-keep-hearing-about\">What's this \"Edwards Curve\" I keep hearing about?<br></h3><p>Most Elliptic curves are <a href=\"https://en.wikipedia.org/wiki/Montgomery_curve\"><strong>Montgomery Curves</strong></a>. Edwards Curves were described by mathematician Harold Edwards and popularized by cryptographer Daniel Bernstein. They have a different structure that allows for a faster signature algorithm. This signature algorithm, when performed on an Edwards curve, is called <strong>EdDSA</strong>. This algorithm runs in constant time, meaning it's faster and leaks less information</p><h3 id=\"can-edwards-curves-do-key-sharing\">Can Edwards Curves do key sharing?<br></h3><p>Edwards curves are specifically used for signatures. There is not a related Diffie-Hellman key sharing algorithm.</p><h3 id=\"so-if-i-want-to-use-both-ecdh-eddsa-i-need-two-key-pairs\">So if I want to use both ECDH &amp; EdDSA, I need two key pairs?<br></h3><p>Not exactly. Let's take the most common Edwards curve <strong>Ed25519</strong>. This curve is related to Montgomery curve <strong>Curve25519</strong>. In fact Ed25519 is a <strong><a href=\"https://en.wikipedia.org/wiki/Twists_of_curves\">twist</a></strong> of Curve25519. A \"twist\" basically means that the curves are mappable to one another. What this means is that you can use the same private key to generate a public key on both curves and then transform those public keys between one another without any knowledge of the private key. Specifically, with these equations.</p><!--kg-card-begin: markdown--><pre><code>(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)\n(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))\n</code></pre>\n<p>where <code>(u, v)</code> is the Curve25519 point and <code>(x, y)</code> is the Ed25519 point</p>\n<!--kg-card-end: markdown--><p>You can read a more in-depth post about that <a href=\"https://blog.filippo.io/using-ed25519-keys-for-encryption/\">Here</a>.</p><h3 id=\"what-cryptography-algorithms-do-protocols-like-bitcoin-ethereum-and-ipfs-use\">What cryptography algorithms do protocols like Bitcoin, Ethereum, and IPFS use?<br></h3><p>Bitcoin uses <strong>secp256k1</strong> for <a href=\"https://bitcointalk.org/index.php?topic=2699.msg37328#msg37328\">completely arbitrary reasons</a><br>Etherem uses <strong>secp256k1</strong> for <a href=\"https://forum.ethereum.org/discussion/comment/53/#Comment_53\">interop with Bitcoin</a><br>IPFS uses <strong>Ed25519</strong> and <strong>RSA</strong>.</p><h3 id=\"okay-so-what-do-you-recommend\">Okay so what do you recommend?</h3><!--kg-card-begin: markdown--><p>We're using Ed25519 &amp; Curve25519. We chose these because:</p>\n<ul>\n<li>They are well-recognized as <a href=\"https://safecurves.cr.yp.to/\">safe curves</a></li>\n<li>They are one of the more commonly used curves, so we have easier interop</li>\n<li>They allow us to use EdDSA for signatures</li>\n<li>We're fairly certain that they don't have any backdoors in them</li>\n</ul>\n<!--kg-card-end: markdown--><h3 id=\"this-is-sweet-why-doesn-t-everyone-have-a-private-key\">This is sweet! Why doesn't everyone have a private key??<br></h3><p>We ask ourselves the same question everyday. The main reason is: it's a pain. Keys look scary (<code>6A576D5A7134743777217A25432A462D4A614...</code>). And if you lose a key, you're forever screwed. There's no \"recovery by email\" available. </p><h3 id=\"what-are-people-doing-about-this\">What are people doing about this?<br></h3><!--kg-card-begin: markdown--><p>We need to fix the UX of public keys. Remove the scary hexadecimal strings and provide more painless recovery.</p>\n<p>A few options are</p>\n<ul>\n<li>Replication: Share the same key across multiple devices. If you drop your phone in a lake, you can recover your key with your laptop</li>\n<li>Shamir Secret Sharing: This involves splitting a key up into separate &quot;shares&quot;. Each share reveals nothing about the key, but by combining the shares back together, you can recover the private key. This leads to interesting solutions like <a href=\"https://www.coindesk.com/pay-your-friends-to-protect-your-keys-one-startups-new-take-on-crypto-custody\">social recovery</a> or <a href=\"https://medium.com/@amanladia1/zerowallet-a-zkp-based-wallet-authentication-mechanism-9871dcca0a01\">zero-knowledge key recovery</a> which we implemented as a <a href=\"https://github.com/fission-suite/zerowallet-poc\">Proof of Concept</a>.</li>\n<li>Secure Hardware Enclaves: Many phones and computers that are coming out these days have Secure Hardware Enclaves. These use both hardware and software to provide <em>very</em> strong security gurantees</li>\n<li>Hardware Secure Modules (HSMs): These are similar to Secure Hardware Enclaves, but larger and hold more information. Physical modules exist, and you can also rent space from cloud providers such as AWS. Less security-minded users might be interested in backing up their keys with a &quot;trusted custodian&quot; (this still ends up being quite a bit safer than the internet's current security model).</li>\n</ul>\n<!--kg-card-end: markdown--><h3 id=\"how-are-you-using-private-keys\">How are you using private keys?<br></h3><p>Here at Fission, we wanted to get private keys into the hands of our users as quickly as possible. We just rolled out our new authentication scheme which uses private keys to power our command line tool: <a href=\"https://github.com/fission-suite/cli\">Fission Live</a>. Give it a go and let us know what you think! We have other big projects coming down the pipeline soon that will use this public key infrastructure to power some really neat features: a global encrypted filesystem, cryptographically verifiable claims, and more!</p>","url":"https://blog.fission.codes/everything-you-wanted-to-know-about-elliptic-curve-cryptography/","canonical_url":null,"uuid":"c045a827-06e6-4b75-895e-782a8b2ddfce","page":false,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5e274d05fbc2c9001eeb9759","reading_time":null}}]}},"pageContext":{"slug":"technology-highlight","pageNumber":0,"humanPageNumber":1,"skip":0,"limit":12,"numberOfPages":1,"previousPagePath":"","nextPagePath":""}},"staticQueryHashes":["1752937443","2358152166","2561578252","2731221146","4145280475"]}