{"data":{"ghostTag":{"slug":"jwt","name":"jwt","feature_image":null,"description":null,"meta_title":null,"meta_description":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5eb19b7a82ce80001ee86716","title":"UCAN: Authorizing Users Without a Back End","slug":"auth-without-backend","featured":true,"feature_image":"https://s3.fission.codes/2020/05/zdenek-machacek-EtxsgEcHnZg-unsplash.jpg","excerpt":"User Controlled Authorization Networks (UCANs) are a way of doing authorization (\"what you can do\") where users are fully in control.","custom_excerpt":"User Controlled Authorization Networks (UCANs) are a way of doing authorization (\"what you can do\") where users are fully in control.","created_at_pretty":"05 May, 2020","published_at_pretty":"07 May, 2020","updated_at_pretty":"26 May, 2020","created_at":"2020-05-05T09:59:38.000-07:00","published_at":"2020-05-07T12:23:57.000-07:00","updated_at":"2020-05-26T15:19:05.000-07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Brooklyn Zelenka","slug":"expede","bio":"CTO at Fission ‚ô•Œª Programs with functions","profile_image":"https://s3.fission.codes/2019/05/IMG_2934-square.jpeg","twitter":"@expede","facebook":null,"website":null}],"primary_author":{"name":"Brooklyn Zelenka","slug":"expede","bio":"CTO at Fission ‚ô•Œª Programs with functions","profile_image":"https://s3.fission.codes/2019/05/IMG_2934-square.jpeg","twitter":"@expede","facebook":null,"website":null},"primary_tag":{"name":"Technology Highlight","slug":"technology-highlight","description":null,"feature_image":null,"meta_description":null,"meta_title":null},"tags":[{"name":"Technology Highlight","slug":"technology-highlight","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"ucan","slug":"ucan","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"auth","slug":"auth","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"authorization","slug":"authorization","description":null,"feature_image":null,"meta_description":null,"meta_title":null},{"name":"jwt","slug":"jwt","description":null,"feature_image":null,"meta_description":null,"meta_title":null}],"plaintext":"Fission is building a system which \"makes the right thing the easy thing.\" It\nlets you write apps for the browser without having to write or deploy a back\nend. We're making use of fairly recent browser features and W3C standards to\nmake this all possible. Read on for a technical summary, or join us in the\ndeveloper forum [https://talk.fission.codes]  to get into more detail.\n\nOne of the most common tasks for apps is authorizing users to perform some\naction, like storing new data to storage, updating records, or fetching a file. \n\nTraditional app architecture has many users share one database (\"multi-tenant\"),\nwith all user data fully interleaved with each other. Authorization here is\nprimarily focused on keeping users from editing each other's records on this\nshared infrastructure. The server's rules give fairly coarse-grained control.\nDue to the inevitable exceptions to these rules, the logic becomes increasingly\ncomplex over time.\n\nEven in a microservice architecture, typically all requests are funneled through\na central authorization service. Over time this causes several challenges,\nincluding complex logic, cost of maintenance, tricky edge cases, and difficulty\nmanaging traffic spikes. In short: it doesn't scale well.\n\nEven incumbents like  Google are moving away from the traditional auth server\nmodel [https://research.google/pubs/pub41892/]  to overcome the above\nchallenges. Fission has different constraints from Google and Amazon, but can\nadapt a lot of these ideas for our purposes. Essentially they're moving from a\ncentral auth server setup to a distributed model where more power is delegated\nto services.\n\nWhat if we learn from Google's approach (plus older approaches like SDSI/SPKI\n[https://tools.ietf.org/html/rfc2693]) but took it to its logic conclusion?\n\nIntroducing UCANs\n> User Controlled Authorization Networks (UCANs) are a way of doing authorization\nwhere users are fully in control. OAuth is designed for a centralized world,\nUCAN is the distributed user controlled version.\nUCAN SamAt a high level, User Controlled Authorization Networks (UCANs) are a\nway of doing authorization (\"what you can  do\") where users are fully in\ncontrol. There's no all-powerful authorization server, or server of any kind\nrequired. Everything that a users is allowed to do is captured directly in a key\nor token, and can be sent to anyone that knows how to interpret this format.\n\nSince all Fission accounts are equipped with a global ID and cryptographic keys,\nwe were able to design a system that has very few assumptions and thus works in\na huge number of situations.\n\nThis setup has several advantages:\n\n 1. Low effort:¬†developers don't need to write and maintain complex access logic\n 2. Familiar:¬†uses very common JSON Web Tokens (JWTs)\n 3. Invisible: users don't need to know that anything special is happening\n 4. Flexible: access can be granted as coarse or granular as the end users wants\n 5. Scalable: no auth server bottleneck / scales infinitely\n 6. Secure:¬†military-grade encryption\n 7. Collaborative:¬†users and services and delegate a subset of their access to\n    others\n 8. Self-contained: the token contains all the information needed to verify it\n\nUCANs are all that we need to sign into multiple machines, delegate access for\nservice providers to do things while we're offline, securely collaborate on\ndocuments with a team, and more. We get the flexibility of fine- or\ncoarse-grained control, all controlled by the one who cares about the data the\nmost: the user.\n\nWe've implemented this as the authorization system for Fission, and are also\nmaking this available as a building block for developers to solve user\nauthorization and delegation within their own applications.\n\n\n--------------------------------------------------------------------------------\n\nThis system of authorization is broken into two halves: read and write (or\n\"command and query\", depending on your background). Without getting too in the\nweeds, here's a high level description of how this all works:\n\nRead (Query) Access\nRead access comes in three flavours: public, private, and unlisted. Access\nfollows the object-capability model\n[https://en.wikipedia.org/wiki/Object-capability_model?oldformat=true], where\nanyone with the reference (URL or CID) and cryptograhic key can read the data by\nvirtue of having access to these.\n\nPublic üëÄ\nPublic files are just that: files that can be discovered or accessed by anyone\nat an easy-to read path.\n\nHere's a live example: https://boris.fission.name/Photos/boris-with-icecream.jpg\n\nPrivate üîê\nThe user encrypts the data, and shares the key with those that should have\naccess. The contents of a private directory is only readable with a key, but\nonce you have access to that directory, all of the data in that directory\n(including subdirectories and metadata) is accessible.\n\nThe end experience matches the behaviour in other online consumer file storage\nsolutions like Dropbox and Google Drive. A major difference with Fission is that\nthe end user is given complete control over who has access, and access does not\ndepend on Fission's servers being accessible (i.e. you're offline or Fission\ndisappears).\n\nUnlisted üó∫Ô∏è\nSort of a mashup of public and private files! This is useful when you want to\n(e.g.) embed an image in an email without distributing keys, but also don't want\nit easily discoverable.\n\nThe unlisted files themselves are left unencrypted, but finding them is\npractically infeasible without the private index. Think of this index as a\nsecret treasure map for the web ‚Äî the map itself private (only a select few have\nthe map), but anyone with it can find the data at the marked locations.\n\nUnder the hood, the Fission SDK creates a JSON file that lists all of the\nlocations. That JSON file is then encrypted and the key passed to whoever should\nhave access., or the links can be shared directly.\n\nHere's a simple example of what this looks like:\n\n// The \"treasure map\"\n{\n  \"QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ\": {\n      \"cat.jpg\": \"Qmd286K6pohQcTKYqnS1YhWrCiS4gz7Xi34sdwMe9USZ7u\"\n  }\n}\n\n# URL\nhttps://ipfs.runfission.com/ipfs/QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ/cat.jpg\n\nWrite (Command) Access üñäÔ∏è\nThere are some actions that a user needs the help of another user or service to\nperform. For example: sending an email, or updating DNS.\n\nIn a traditional OAuth based system, the \"account\" lives entirely on the server,\nand the user is granted access with a token. In Fission's design, the account is\na key pair, and a UCAN is equivalent to an OAuth token. OAuth is designed for a\ncentralized client/server world. UCANs are the distributed user controlled\nequivalent.\n\nUCANs are simply JWT [jwt.io]s that contain special keys. Much of this will look\nfamiliar if you've done web auth in the past decade or so. Here's an example:\n\n{\n  \"alg\": \"Ed25519\",\n  \"typ\": \"JWT\"\n  \"uav\": \"0.1.0\"\n}\n{\n  \"aud\": \"did:key:zStEZpzSMtTt9k2vszgvCwF4fLQQSyA15W5AQ4z3AR6Bx4eFJ5crJFbuGxKmbma4\",\n  \"iss\": \"did:key:z5C4fuP2DDJChhMBCwAkpYUMuJZdNWWH5NeYjUyY8btYfzDh3aHwT5picHr9Ttjq\",\n  \"nbf\": 1588713622,\n  \"exp\": 1589000000,\n  \"scp\": \"/\"\n  \"ptc\": \"APPEND\",\n  \"prf\": null,\n}\n\nExample UCAN JSON Web TokenBearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsInVhdiI6IjAuMS4wIn0.eyJhdWQiOiJkaW\nQ6a2V5OnpTdEVacHpTTXRUdDlrMnZzemd2Q3dGNGZMUVFTeUExNVc1QVE0ejNBUjZCeDRl\nRko1Y3JKRmJ1R3hLbWJtYTQiLCJpc3MiOiJkaWQ6a2V5Ono1QzRmdVAyRERKQ2hoTUJDd0\nFrcFlVTXVKWmROV1dINU5lWWpVeVk4YnRZZnpEaDNhSHdUNXBpY0hyOVR0anEiLCJuYmYi\nOjE1ODg3MTM2MjIsImV4cCI6MTU4OTAwMDAwMCwic2NwIjoiLyIsInB0YyI6IkFQUEVORC\nIsInByZiI6bnVsbH0.Ay8C5ajYWHxtD8y0msla5IJ8VFffTHgVq448Hlr818JtNaTUzNIw\nFiuutEMECGTy69hV9Xu9bxGxTe0TpC7AzV34p0wSFax075mC3w9JYB8yqck_MEBg_dZ1xl\nJCfDve60AHseKPtbr2emp6hZVfTpQGZzusstimAxyYPrQUWv9wqTFmin0Ls-loAWamleUZ\noE1Tarlp_0h9SeV614RfRTC0e3x_VP9Ra_84JhJHZ7kiLf44TnyPl_9AbzuMdDwCvu-zX\njd_jMlDyYcuwamJ15XqrgykLOm0WTREgr_sNLVciXBXd6EQ-Zh2L7hd38noJm1P_MIr9_\nEDRWAhoRLXPQ\n\nThe same, as a bearer token (for an HTTP Authorization  header)Let's break that\ndown:\n\nHeader üìã\nThis is a standard JWT header, plus a uav  field.\n\n * alg  ‚Äî type of signature\n * typ  ‚Äî¬†state that this is a JWT\n * uav  ‚Äî \"UCAN version\" (so we can track the format of when it was issued)\n\nBody üí™\n * aud  \"Audience\" ‚Äî¬†the ID of who it's intended for (the \"to\" field)\n * iss  \"Issuer\" ‚Äî¬†ID of who sent it (the \"from\" field)\n * nbf  \"Not Before\" ‚Äî¬†Unix timestamp of when it becomes valid (typically when\n   it was created, but not always)\n * exp  \"Expiry\" ‚Äî¬†Unix timestamp of when it stops being valid\n * scp  \"Scope\" ‚Äî¬†The scope of things it's able to change (e.g. a file system\n   path)\n * ptc  \"Potency\" ‚Äî what rights comes with the token (in this case it's append\n   only)\n * prf  \"Proof\" ‚Äî an optional nested token with equal or greater privileges\n\nThese are then all signed with the user's private key. This key must match the\npublic key in the iss  field (user IDs are public keys), directly authenticating\nthe token. As the token is a complete description of access, this token is\nself-validating with no need to look at other data or services.\n\nDelegation ü§ù\nWhat if you want to grant another user or service the ability to perform some\naction on your behalf? As long as they have a valid UCAN, they can wrap it in\nanother with equal or lesser rights and include the original in the prf  field.\n\nSince every UCAN layer is self-signed, we can trace back to the root (no prf \nfield), and know who the delegate is acting as. This chain of tokens is itself\nis the proof that you're perform some action.\n\nFor example, here's a chain:\n\n\"prf\":\"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\n       eyJhdWQiOiJkaWQ6a2V5OnpTdEVacHpTTXRUdDlrMnZz\n       emd2Q3dGNGZMUVFTeUExNVc1QVE0ejNBUjZCeDRlRko1\n       Y3JKRmJ1R3hLbWJtYTQiLCJleHAiOjE1ODgyNjU0MjAs\n       ImlzcyI6ImRpZDprZXk6ejFMQm53RWt0d1lMcnBQaHV3\n       Rm93ZFZ3QUZYNXpwUm85cnJWendpUlJCQmlhQm9DUjdo\n       TnFnc3RXN1ZNM1Q5YXVOYnFUbVFXNHZkSGI2MVJoVE1W\n       Z0NwMUJUeHVhS1UzYW5Xb0VSRlhwdVp2ZkUzOWc4dTdI\n       UzlCZUQxUUpOMWZYNlM4dnZza2FQaHhGa3dMdEdyNFpm\n       ZmtVRTU3V1pwTldNNlU2QnFka3RaeG1LenhDODV6TjRG\n       QzlXczVMSHVHZnhhQ3VCTGlVZkE3cUVZVlN6MVF1MXJa\n       RHBENk55ZlVOckhKMUVyWmR1SnVuOTc2bmJGSHJtRG5V\n       NDdSY1NNRkVTYk5LRGkxNDY3dFJmdWJzTXJEemViZENG\n       S1EybTFBWXlzdG8yaTZXbWNudWNqdDN0bndUcWU3Qm84\n       TDFnOGg4VUdBOTQ2REYzV2VHYlBVR3F6bnNVZExxNlhM\n       Q21KekprSm1yTnllWmtzd2R5UFgyVnU2SjlFNEoxMlNi\n       M2g5ZHM3YXRCeWFtZnRpdEVac2Y2aFBKa0xVWEdUaFlw\n       Q25tUkFBclJSZlBZMkg2Y0tEYzdBY25GUHlOSEdrYWI1\n       WkZvNHF2Z0JaeXRiSzFLNW9EM0hmUTZFMnliTGh5QzJi\n       OGk1d282REx0bTl1Zml4U0pOTlRIN1Vpa2s4OENtZXJ0\n       S1I3czEyQ0sxV0xFTTNadTVZQlpOcGhuamo3Y3A4UVRv\n       ZEFlaFJQVjlORzFDTEVBTUpWTjc5RHZZZTZTZmlhZkpv\n       YmN2ZkQ4bnBmUzZqY2VqY3lvdVFiRXBLREc3UUFuS1M0\n       OFA0QXZnQnFEdmZOVWU1NGpNa2s2cjZDb1g0TGNZR0h1\n       a1pERW5lYTlrd2tFb1hrVVlTNGoxQWZiS2g0NEZ6U3VY\n       YlFxWm5qalZwVGh4Q05tbU5uMUU0cUhtc0ZrdkdvRjNG\n       TjU1Q1Brb0dmREN2eVFKZ3Ftc0ZtcGVUSlN5OXd6djRN\n       dmJxcHVBVHhyN2V5eHNHZUNXUWtjRHd1YjMyaW5HcFIz\n       cmVUZnpSSkVDQ0ZaYXJuWGRjQzVQaWRha2IxV3U4TCIs\n       Im5iZiI6MCwicHRjIjoiQVBQRU5EIiwicHJmIjpudWxs\n       LCJzY3AiOiIvIn0.leyE9w2TF28espPq6mOWziQuJny2\n       GHH_wajV6S9q4gF9SLP-i9JaX_XbkHlE1GhpQ36gSs6F\n       v4_AXSuJzDkUhnAA-oPsI5bSHl28XbobzqdmXtQ2liK-\n       Gum7kUtF1CPXlIamV0NIUlCKLlaUgFod5ZQvvA19kMHU\n       ugDGm8O3G98TSm3qLlG-eoFNVXr0NSpvLeui3kQbdBsP\n       GMykaTsUn1fNLI3oKkK6JvUIq4po6gIidTdOJDlS7y_W\n       4bdMXUQcTprtpd2QmTqwTzws9tu4GBdx7q1vz35LiG39\n       ohhRs2NKB4rxbZK2O9kX1G2xLMSETE_YT9GR04XWMnFo\n       eIodsg\"\n\nNested proofYou'll notice that the nested proof is encoded as a bearer token.\nThis is because it needs to include its signature to prove that it's valid, and\na JWT signature is on the content encoded this way.\n\nThis token is thus valid as long as:\n\n * All token signatures are correct\n * The time range, potency, and scope of prf  are greater-or-equal to the\n   enclosing token\n * The outer token's iss  field matches the prf's aud  field (chain \"to\" and\n   \"from\" correctly)\n * The timestamps are valid at the present time\n\nHashing Ô∏è üèéÔ∏è\nThese chains can get large, so you can optionally hash the outermost one before\nsending to a server. This acts as a \"content address\", meaning that if the\nservice hasn't seen it before, it can separately request that token, but if it\nalready has it in cache and doesn't need to get it over the network. Since\nhashes are much smaller than their content, this can save a lot of bandwidth on\nrepeated requests.\n\n\"prf\": \"QmU5WJTTp9vtMN1PBJpTV9xWXbTFBcWx3qjPGuXJXtujyd\"\n\nSame as the example above, but with the proof compressed to a content address\nConclusion\nUCANs are a straightforward way of doing authorization that leverage the public\nkey infrastructure already baked into Fission. This is essentially\nauthorization-at-the-edge with familiar JWTs. Since the token is self-contained,\nit's infinitely scalable. It's also very flexible: the user can grant root\naccess to everything, or grant a tab write access to a single object for one\nminute.\n\nThis article covers everything that you need to use a UCAN. For those interested\nin the space at a deeper level, there's a lot more background and technical\ndesign thinking that we didn't cover here. Keep an eye on our developer forum\n[talk.fission.codes]  for an upcoming article detailing the deeper internals!","html":"<p>Fission is building a system which \"makes the right thing the easy thing.\" It lets you write apps for the browser without having to write or deploy a back end. We're making use of fairly recent browser features and W3C standards to make this all possible. Read on for a technical summary, or <a href=\"https://talk.fission.codes\">join us in the developer forum</a> to get into more detail.</p><p>One of the most common tasks for apps is authorizing users to perform some action, like storing new data to storage, updating records, or fetching a file. </p><p>Traditional app architecture has many users share one database (\"multi-tenant\"), with all user data fully interleaved with each other. Authorization here is primarily focused on keeping users from editing each other's records on this shared infrastructure. The server's rules give fairly coarse-grained control. Due to the inevitable exceptions to these rules, the logic becomes increasingly complex over time.</p><p>Even in a microservice architecture, typically all requests are funneled through a central authorization service. Over time this causes several challenges, including complex logic, cost of maintenance, tricky edge cases, and difficulty managing traffic spikes. In short: it doesn't scale well.</p><p>Even incumbents like<a href=\"https://research.google/pubs/pub41892/\"> Google are moving away from the traditional auth server model</a> to overcome the above challenges. Fission has different constraints from Google and Amazon, but can adapt a lot of these ideas for our purposes. Essentially they're moving from a central auth server setup to a distributed model where more power is delegated to services.</p><p>What if we learn from Google's approach (plus older approaches like <a href=\"https://tools.ietf.org/html/rfc2693\">SDSI/SPKI</a>) but took it to its logic conclusion?</p><h2 id=\"introducing-ucans\">Introducing UCANs</h2><blockquote>User Controlled Authorization Networks (UCANs) are a way of doing authorization where users are fully in control. OAuth is designed for a centralized world, UCAN is the distributed user controlled version.</blockquote><!--kg-card-begin: image--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://s3.fission.codes/2020/05/UCAN_SAM-1.png\" class=\"kg-image\"><figcaption>UCAN Sam</figcaption></figure><!--kg-card-end: image--><p>At a high level, User Controlled Authorization Networks (UCANs) are a way of doing authorization (\"what <em>you can</em> do\") where users are fully in control. There's no all-powerful authorization server, or server of any kind required. Everything that a users is allowed to do is captured directly in a key or token, and can be sent to anyone that knows how to interpret this format.</p><p>Since all Fission accounts are equipped with a global ID and cryptographic keys, we were able to design a system that has very few assumptions and thus works in a huge number of situations.</p><p>This setup has several advantages:</p><ol><li>Low effort:¬†developers don't need to write and maintain complex access logic</li><li>Familiar:¬†uses very common JSON Web Tokens (JWTs)</li><li>Invisible: users don't need to know that anything special is happening</li><li>Flexible: access can be granted as coarse or granular as the end users wants</li><li>Scalable: no auth server bottleneck / scales infinitely</li><li>Secure:¬†military-grade encryption</li><li>Collaborative:¬†users and services and delegate a subset of their access to others</li><li>Self-contained: the token contains all the information needed to verify it</li></ol><p>UCANs are all that we need to sign into multiple machines, delegate access for service providers to do things while we're offline, securely collaborate on documents with a team, and more. We get the flexibility of fine- or coarse-grained control, all controlled by the one who cares about the data the most: the user.</p><p>We've implemented this as the authorization system for Fission, and are also making this available as a building block for developers to solve user authorization and delegation within their own applications.</p><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><p>This system of authorization is broken into two halves: read and write (or \"command and query\", depending on your background). Without getting too in the weeds, here's a high level description of how this all works:</p><h2 id=\"read-query-access\">Read (Query) Access</h2><p>Read access comes in three flavours: public, private, and unlisted. Access follows the <a href=\"https://en.wikipedia.org/wiki/Object-capability_model?oldformat=true\">object-capability model</a>, where anyone with the reference (URL or CID) and cryptograhic key can read the data by virtue of having access to these.</p><h3 id=\"public-\">Public üëÄ</h3><p>Public files are just that: files that can be discovered or accessed by anyone at an easy-to read path.</p><p>Here's a live example: <a href=\"https://boris.fission.name/Photos/boris-with-icecream.jpg\">https://boris.fission.name/Photos/boris-with-icecream.jpg</a></p><h3 id=\"private-\">Private üîê</h3><p>The user encrypts the data, and shares the key with those that should have access. The contents of a private directory is only readable with a key, but once you have access to that directory, all of the data in that directory (including subdirectories and metadata) is accessible.</p><p>The end experience matches the behaviour in other online consumer file storage solutions like Dropbox and Google Drive. A major difference with Fission is that the end user is given complete control over who has access, and access does not depend on Fission's servers being accessible (i.e. you're offline or Fission disappears).</p><h3 id=\"unlisted-\">Unlisted üó∫Ô∏è</h3><p>Sort of a mashup of public and private files! This is useful when you want to (e.g.) embed an image in an email without distributing keys, but also don't want it easily discoverable.</p><p>The unlisted files themselves are left unencrypted, but finding them is practically infeasible without the private index. Think of this index as a secret treasure map for the web ‚Äî the map itself private (only a select few have the map), but anyone with it can find the data at the marked locations.</p><p>Under the hood, the Fission SDK creates a JSON file that lists all of the locations. That JSON file is then encrypted and the key passed to whoever should have access., or the links can be shared directly.</p><p>Here's a simple example of what this looks like:</p><!--kg-card-begin: code--><pre><code class=\"language-javascript\">// The \"treasure map\"\n{\n  \"QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ\": {\n      \"cat.jpg\": \"Qmd286K6pohQcTKYqnS1YhWrCiS4gz7Xi34sdwMe9USZ7u\"\n  }\n}</code></pre><!--kg-card-end: code--><!--kg-card-begin: code--><pre><code class=\"language-URL\"># URL\nhttps://ipfs.runfission.com/ipfs/QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ/cat.jpg</code></pre><!--kg-card-end: code--><h2 id=\"write-command-access-\">Write (Command) Access üñäÔ∏è</h2><p>There are some actions that a user needs the help of another user or service to perform. For example: sending an email, or updating DNS.</p><p>In a traditional OAuth based system, the \"account\" lives entirely on the server, and the user is granted access with a token<em><em>. </em></em>In Fission's design, the account is a key pair, and a UCAN is equivalent to an OAuth token. OAuth is designed for a centralized client/server world. UCANs are the distributed user controlled equivalent.</p><p>UCANs are simply <a href=\"jwt.io\">JWT</a>s that contain special keys. Much of this will look familiar if you've done web auth in the past decade or so. Here's an example:</p><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-json\">{\n  \"alg\": \"Ed25519\",\n  \"typ\": \"JWT\"\n  \"uav\": \"0.1.0\"\n}\n{\n  \"aud\": \"did:key:zStEZpzSMtTt9k2vszgvCwF4fLQQSyA15W5AQ4z3AR6Bx4eFJ5crJFbuGxKmbma4\",\n  \"iss\": \"did:key:z5C4fuP2DDJChhMBCwAkpYUMuJZdNWWH5NeYjUyY8btYfzDh3aHwT5picHr9Ttjq\",\n  \"nbf\": 1588713622,\n  \"exp\": 1589000000,\n  \"scp\": \"/\"\n  \"ptc\": \"APPEND\",\n  \"prf\": null,\n}</code></pre><figcaption>Example UCAN JSON Web Token</figcaption></figure><!--kg-card-end: code--><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code>Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsInVhdiI6IjAuMS4wIn0.eyJhdWQiOiJkaW\nQ6a2V5OnpTdEVacHpTTXRUdDlrMnZzemd2Q3dGNGZMUVFTeUExNVc1QVE0ejNBUjZCeDRl\nRko1Y3JKRmJ1R3hLbWJtYTQiLCJpc3MiOiJkaWQ6a2V5Ono1QzRmdVAyRERKQ2hoTUJDd0\nFrcFlVTXVKWmROV1dINU5lWWpVeVk4YnRZZnpEaDNhSHdUNXBpY0hyOVR0anEiLCJuYmYi\nOjE1ODg3MTM2MjIsImV4cCI6MTU4OTAwMDAwMCwic2NwIjoiLyIsInB0YyI6IkFQUEVORC\nIsInByZiI6bnVsbH0.Ay8C5ajYWHxtD8y0msla5IJ8VFffTHgVq448Hlr818JtNaTUzNIw\nFiuutEMECGTy69hV9Xu9bxGxTe0TpC7AzV34p0wSFax075mC3w9JYB8yqck_MEBg_dZ1xl\nJCfDve60AHseKPtbr2emp6hZVfTpQGZzusstimAxyYPrQUWv9wqTFmin0Ls-loAWamleUZ\noE1Tarlp_0h9SeV614RfRTC0e3x_VP9Ra_84JhJHZ7kiLf44TnyPl_9AbzuMdDwCvu-zX\njd_jMlDyYcuwamJ15XqrgykLOm0WTREgr_sNLVciXBXd6EQ-Zh2L7hd38noJm1P_MIr9_\nEDRWAhoRLXPQ</code></pre><figcaption>The same, as a bearer token (for an HTTP <code>Authorization</code> header)</figcaption></figure><!--kg-card-end: code--><p>Let's break that down:</p><h2 id=\"header-\">Header üìã</h2><p>This is a standard JWT header, plus a <code>uav</code> field.</p><ul><li><code>alg</code> ‚Äî type of signature</li><li><code>typ</code> ‚Äî¬†state that this is a JWT</li><li><code>uav</code> ‚Äî \"UCAN version\" (so we can track the format of when it was issued)</li></ul><h2 id=\"body-\">Body üí™</h2><ul><li><code>aud</code> \"Audience\" ‚Äî¬†the ID of who it's intended for (the \"to\" field)</li><li><code>iss</code> \"Issuer\" ‚Äî¬†ID of who sent it (the \"from\" field)</li><li><code>nbf</code> \"Not Before\" ‚Äî¬†Unix timestamp of when it becomes valid (typically when it was created, but not always)</li><li><code>exp</code> \"Expiry\" ‚Äî¬†Unix timestamp of when it stops being valid</li><li><code>scp</code> \"Scope\" ‚Äî¬†The scope of things it's able to change (e.g. a file system path)</li><li><code>ptc</code> \"Potency\" ‚Äî what rights comes with the token (in this case it's append only)</li><li><code>prf</code> \"Proof\" ‚Äî an optional nested token with equal or greater privileges</li></ul><p>These are then all signed with the user's private key. This key must match the public key in the <code>iss</code> field (user IDs are public keys), directly authenticating the token. As the token is a complete description of access, this token is self-validating with no need to look at other data or services.</p><h3 id=\"delegation-\">Delegation ü§ù</h3><p>What if you want to grant another user or service the ability to perform some action on your behalf? As long as they have a valid UCAN, they can wrap it in another with equal or lesser rights and include the original in the <code>prf</code> field.</p><p>Since every UCAN layer is self-signed, we can trace back to the root (no <code>prf</code> field), and know who the delegate is acting as. This chain of tokens is itself is the proof that you're perform some action.</p><p>For example, here's a chain:</p><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-plaintext\">\"prf\":\"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\n       eyJhdWQiOiJkaWQ6a2V5OnpTdEVacHpTTXRUdDlrMnZz\n       emd2Q3dGNGZMUVFTeUExNVc1QVE0ejNBUjZCeDRlRko1\n       Y3JKRmJ1R3hLbWJtYTQiLCJleHAiOjE1ODgyNjU0MjAs\n       ImlzcyI6ImRpZDprZXk6ejFMQm53RWt0d1lMcnBQaHV3\n       Rm93ZFZ3QUZYNXpwUm85cnJWendpUlJCQmlhQm9DUjdo\n       TnFnc3RXN1ZNM1Q5YXVOYnFUbVFXNHZkSGI2MVJoVE1W\n       Z0NwMUJUeHVhS1UzYW5Xb0VSRlhwdVp2ZkUzOWc4dTdI\n       UzlCZUQxUUpOMWZYNlM4dnZza2FQaHhGa3dMdEdyNFpm\n       ZmtVRTU3V1pwTldNNlU2QnFka3RaeG1LenhDODV6TjRG\n       QzlXczVMSHVHZnhhQ3VCTGlVZkE3cUVZVlN6MVF1MXJa\n       RHBENk55ZlVOckhKMUVyWmR1SnVuOTc2bmJGSHJtRG5V\n       NDdSY1NNRkVTYk5LRGkxNDY3dFJmdWJzTXJEemViZENG\n       S1EybTFBWXlzdG8yaTZXbWNudWNqdDN0bndUcWU3Qm84\n       TDFnOGg4VUdBOTQ2REYzV2VHYlBVR3F6bnNVZExxNlhM\n       Q21KekprSm1yTnllWmtzd2R5UFgyVnU2SjlFNEoxMlNi\n       M2g5ZHM3YXRCeWFtZnRpdEVac2Y2aFBKa0xVWEdUaFlw\n       Q25tUkFBclJSZlBZMkg2Y0tEYzdBY25GUHlOSEdrYWI1\n       WkZvNHF2Z0JaeXRiSzFLNW9EM0hmUTZFMnliTGh5QzJi\n       OGk1d282REx0bTl1Zml4U0pOTlRIN1Vpa2s4OENtZXJ0\n       S1I3czEyQ0sxV0xFTTNadTVZQlpOcGhuamo3Y3A4UVRv\n       ZEFlaFJQVjlORzFDTEVBTUpWTjc5RHZZZTZTZmlhZkpv\n       YmN2ZkQ4bnBmUzZqY2VqY3lvdVFiRXBLREc3UUFuS1M0\n       OFA0QXZnQnFEdmZOVWU1NGpNa2s2cjZDb1g0TGNZR0h1\n       a1pERW5lYTlrd2tFb1hrVVlTNGoxQWZiS2g0NEZ6U3VY\n       YlFxWm5qalZwVGh4Q05tbU5uMUU0cUhtc0ZrdkdvRjNG\n       TjU1Q1Brb0dmREN2eVFKZ3Ftc0ZtcGVUSlN5OXd6djRN\n       dmJxcHVBVHhyN2V5eHNHZUNXUWtjRHd1YjMyaW5HcFIz\n       cmVUZnpSSkVDQ0ZaYXJuWGRjQzVQaWRha2IxV3U4TCIs\n       Im5iZiI6MCwicHRjIjoiQVBQRU5EIiwicHJmIjpudWxs\n       LCJzY3AiOiIvIn0.leyE9w2TF28espPq6mOWziQuJny2\n       GHH_wajV6S9q4gF9SLP-i9JaX_XbkHlE1GhpQ36gSs6F\n       v4_AXSuJzDkUhnAA-oPsI5bSHl28XbobzqdmXtQ2liK-\n       Gum7kUtF1CPXlIamV0NIUlCKLlaUgFod5ZQvvA19kMHU\n       ugDGm8O3G98TSm3qLlG-eoFNVXr0NSpvLeui3kQbdBsP\n       GMykaTsUn1fNLI3oKkK6JvUIq4po6gIidTdOJDlS7y_W\n       4bdMXUQcTprtpd2QmTqwTzws9tu4GBdx7q1vz35LiG39\n       ohhRs2NKB4rxbZK2O9kX1G2xLMSETE_YT9GR04XWMnFo\n       eIodsg\"</code></pre><figcaption>Nested proof</figcaption></figure><!--kg-card-end: code--><p>You'll notice that the nested proof is encoded as a bearer token. This is because it needs to include its signature to prove that it's valid, and a JWT signature is on the content encoded this way.</p><p>This token is thus valid as long as:</p><ul><li>All token signatures are correct</li><li>The time range, potency, and scope of <code>prf</code> are greater-or-equal to the enclosing token</li><li>The outer token's <code>iss</code> field matches the <code>prf</code>'s <code>aud</code> field (chain \"to\" and \"from\" correctly)</li><li>The timestamps are valid at the present time</li></ul><h3 id=\"hashing-\">Hashing Ô∏è üèéÔ∏è</h3><p>These chains can get large, so you can optionally hash the outermost one before sending to a server. This acts as a \"content address\", meaning that if the service hasn't seen it before, it can separately request that token, but if it already has it in cache and doesn't need to get it over the network. Since hashes are much smaller than their content, this can save a lot of bandwidth on repeated requests.</p><!--kg-card-begin: code--><figure class=\"kg-card kg-code-card\"><pre><code>\"prf\": \"QmU5WJTTp9vtMN1PBJpTV9xWXbTFBcWx3qjPGuXJXtujyd\"</code></pre><figcaption>Same as the example above, but with the proof compressed to a content address</figcaption></figure><!--kg-card-end: code--><h1 id=\"conclusion\">Conclusion</h1><p>UCANs are a straightforward way of doing authorization that leverage the public key infrastructure already baked into Fission. This is essentially authorization-at-the-edge with familiar JWTs. Since the token is self-contained, it's infinitely scalable. It's also very flexible: the user can grant root access to everything, or grant a tab write access to a single object for one minute.</p><p>This article covers everything that you need to use a UCAN. For those interested in the space at a deeper level, there's a lot more background and technical design thinking that we didn't cover here. Keep an eye on <a href=\"talk.fission.codes\">our developer forum</a> for an upcoming article detailing the deeper internals!</p>","url":"https://blog.fission.codes/auth-without-backend/","canonical_url":null,"uuid":"9bd5ed02-502d-4e31-828c-6ad1fa4613b9","page":false,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5eb19b7a82ce80001ee86716","reading_time":null}}]}},"pageContext":{"slug":"jwt","pageNumber":0,"humanPageNumber":1,"skip":0,"limit":12,"numberOfPages":1,"previousPagePath":"","nextPagePath":""}}